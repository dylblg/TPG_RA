<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Wikitude SDK Android 5.1.1 Documentation</title>
    <link type="text/css" rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lato:300,400,700">

    <link type="text/css" rel="stylesheet" href="css/reset.css">
    <link type="text/css" rel="stylesheet" href="css/docs.css">
    <link type="text/css" rel="stylesheet" href="css/print.css" media="print">
    <link type="text/css" rel="stylesheet" href="css/github.min.css">
    <link type="text/css" rel="stylesheet" href="css/default.min.css">
    <link type="text/css" rel="stylesheet" href="css/lightbox.min-0.5.1.css">
    <link type="text/css" rel="stylesheet" href="css/jquery.treemenu.css">

    
    <script type="text/javascript" src="js/jquery-2.1.4.min.js"></script>
    <script type="text/javascript" src="js/highlight-8.6.min.js"></script>
    <script type="text/javascript" src="js/lunr.min-0.5.11.js"></script>
    <script type="text/javascript" src="js/deprecated.js"></script>
    <script type="text/javascript" src="js/lightbox.min-0.5.1.js"></script>
    <script type="text/javascript" src="js/jquery.treemenu.js"></script>

    <script type="text/javascript">
        $(document).ready(function() {
            // Every image referenced from a Markdown document
            $("#content img").each(function() {
                // Let's put a caption if there is one
                if($(this).attr("alt"))
                    $(this).wrap('<figure class="image"></figure>')
                        .after('<figcaption>'+$(this).attr("alt")+'</figcaption>');
                });
        });
    </script>


    <script type="text/javascript">
    hljs.initHighlightingOnLoad();
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            if(isVersionDeprecated())
                document.getElementById('deprecatedNote').style.display='block';
                document.getElementById("documentationSelect").onchange = function() {
                var selectedOption = this.value;
                 console.log(selectedOption);
                 window.top.location.href = "http://www.wikitude.com/developer/documentation/" + selectedOption;
                }
        });
    </script>

</head>
<body>
    <div id="page">
        <a name="top" />
         

<div id="sidebar">
    <div id="topnav">
    <img src="images/150610_WT_SDK_Logo.png">
    <h1><a href="">Documentation</a></h1>
    <h2>Wikitude SDK Android</h2>
    
    <div id="version">version: 5.1.1</div>
    

    
    <select id="documentationSelect">
        
            <option value="android"  selected > Android </option>
        
            <option value="androidnative"  > Android Native API </option>
        
            <option value="phonegap"  > Cordova </option>
        
            <option value="epson"  > Epson </option>
        
            <option value="ios"  > iOS </option>
        
            <option value="iosnative"  > iOS Native API </option>
        
            <option value="glass"  > Google Glass </option>
        
            <option value="vuzix"  > Vuzix </option>
        
            <option value="htmlcss"  > Web </option>
        
            <option value="titanium"  > Titanium </option>
        
            <option value="unity"  > Unity </option>
        
            <option value="xamarin"  > Xamarin </option>
        
            <option value=""  > --- </option>
        
            <option value="cloudrecognition"  > Cloud Recognition </option>
        
            <option value="targetsapi"  > Targets API </option>
        
    </select>
    

    <div id="deprecatedNote" class="warning" style="display:none;">Note you are viewing the documentation of a deprecated version. Please check <a href="http://www.wikitude.com/developer/documentation">www.wikitude.com/developer/documentation</a></div>

    </div>

    <input id="showNav" class="toggleNav" type="checkbox">
    <label class="showNavLbl" for="showNav">Show Navigation</label>
    <label class="hideNavLbl" for="showNav">Hide Navigation</label>

    <div id="mainnav">
    <form action="search.html"><input id="search" type="text" placeholder="Search documentation" name="q" /></form>
    <nav id="toc">
        
    <ul>
    
        <li>
            <a href="gettingstartedandroid.html#getting-started">Getting started</a>
            
                
    <ul>
    
        <li>
            <a href="setupguideandroid.html#setup-guide-android">Setup Guide Android</a>
            
        </li>
    
        <li>
            <a href="supporteddevicesandroid.html#supported-android-devices">Supported Android Devices</a>
            
        </li>
    
        <li>
            <a href="triallicense.html#how-to-obtain-a-free-trial-license">How to obtain a free trial license</a>
            
        </li>
    
        <li>
            <a href="triallicense.html#where-should-i-enter-the-license-key">Where should I enter the license key</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="samples.html#examples">Examples</a>
            
                
    <ul>
    
        <li>
            <a href="clientrecognition.html#client-recognition">Client Recognition</a>
            
        </li>
    
        <li>
            <a href="cloudrecognition.html#cloud-recognition">Cloud Recognition</a>
            
        </li>
    
        <li>
            <a href="3dmodels.html#3d-models">3D Models</a>
            
        </li>
    
        <li>
            <a href="poi.html#point-of-interest-poi">Point Of Interest (POI)</a>
            
        </li>
    
        <li>
            <a href="retrievingpoidata.html#retrieving-poi-data">Retrieving POI Data</a>
            
        </li>
    
        <li>
            <a href="browsingpois.html#browsing-pois">Browsing POIs</a>
            
        </li>
    
        <li>
            <a href="video.html#video-drawables">Video Drawables</a>
            
        </li>
    
        <li>
            <a href="2dtrackingandgeo.html#combine-client-recognition-and-pois">Combine Client Recognition and POIs</a>
            
        </li>
    
        <li>
            <a href="solarsystemir.html#solar-system-ir">Solar System (IR)</a>
            
        </li>
    
        <li>
            <a href="solarsystemgeo.html#solar-system-geo">Solar System (Geo)</a>
            
        </li>
    
        <li>
            <a href="hardwarecontrol.html#hardware-control">Hardware control</a>
            
        </li>
    
        <li>
            <a href="pluginsapi.html#plugins-api">Plugins API</a>
            
        </li>
    
        <li>
            <a href="targetimages.html#target-images">Target Images</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="gettingstartedcloudrecognition.html#wikitude-cloud-recognition">Wikitude Cloud Recognition</a>
            
                
    <ul>
    
        <li>
            <a href="gettingstartedcloudrecognition.html#general-definitions">General Definitions</a>
            
        </li>
    
        <li>
            <a href="gettingstartedcloudrecognition.html#getting-started-with-the-cloud-recognition-service">Getting Started with the Cloud Recognition Service</a>
            
        </li>
    
        <li>
            <a href="gettingstartedcloudrecognition.html#authentication">Authentication</a>
            
        </li>
    
        <li>
            <a href="gettingstartedcloudrecognition.html#quota-and-limits">Quota and Limits</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionworkflow.html#your-first-target-collections">Your first Target Collections</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionworkflow.html#add-target-images">Add Target Images</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionworkflow.html#generate-a-cloud-archive">Generate a Cloud Archive</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionworkflow.html#generate-a-wtc-file">Generate a WTC file</a>
            
        </li>
    
        <li>
            <a href="cloudrecognitionworkflow.html#additional-calls">Additional calls</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="workflow.html#development-workflow">Development Workflow</a>
            
                
    <ul>
    
        <li>
            <a href="workflow.html#code-test-debug">Code, Test, Debug</a>
            
        </li>
    
        <li>
            <a href="workflow.html#on-device-debugging">On-Device Debugging</a>
            
        </li>
    
        <li>
            <a href="assetsworkflow.html#3d-assets-workflow">3D Assets Workflow</a>
            
        </li>
    
        <li>
            <a href="assetsworkflow.html#good-practice">Good practice</a>
            
        </li>
    
        <li>
            <a href="assetsworkflow.html#working-with-3d-animations">Working with 3D Animations</a>
            
        </li>
    
        <li>
            <a href="workingwithvideos.html#augmented-reality-videos">Augmented reality videos</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="tools.html#tools">Tools</a>
            
                
    <ul>
    
        <li>
            <a href="ade.html#ade">ADE</a>
            
        </li>
    
        <li>
            <a href="logger.html#logger">Logger</a>
            
        </li>
    
        <li>
            <a href="targetmanagement.html#target-management">Target Management</a>
            
        </li>
    
        <li>
            <a href="targetguide.html#best-practice-for-target-images">Best practice for target images</a>
            
        </li>
    
        <li>
            <a href="encoder.html#wikitude-3d-encoder">Wikitude 3D Encoder</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="referenceandroid.html#reference">Reference</a>
            
                
    <ul>
    
        <li>
            <a href="referenceandroid.html#android-javadocs">Android JavaDocs</a>
            
        </li>
    
        <li>
            <a href="referenceandroid.html#javascript-api">JavaScript API</a>
            
        </li>
    
        <li>
            <a href="referenceandroid.html#cloud-recognition-manager-api">Cloud Recognition Manager API</a>
            
        </li>
    
        <li>
            <a href="sdu-dbs.html#sdu-and-dbs">SDU and DBS</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="migration.html#migration">Migration</a>
            
                
    <ul>
    
        <li>
            <a href="migration.html#migrate-from-41-to-50">Migrate from 4.1 to 5.0</a>
            
        </li>
    
        <li>
            <a href="migration.html#migrate-from-40-to-41">Migrate from 4.0 to 4.1</a>
            
        </li>
    
        <li>
            <a href="migration.html#migrate-from-33-to-40">Migrate from 3.3 to 4.0</a>
            
        </li>
    
        <li>
            <a href="migration.html#migrate-from-32-to-33">Migrate from 3.2 to 3.3</a>
            
        </li>
    
        <li>
            <a href="migration.html#migrate-from-31-to-32">Migrate from 3.1 to 3.2</a>
            
        </li>
    
        <li>
            <a href="migration.html#migrate-from-30-to-31">Migrate from 3.0 to 3.1</a>
            
        </li>
    
        <li>
            <a href="migration.html#migrate-from-20-to-30">Migrate from 2.0 to 3.0</a>
            
        </li>
    
        <li>
            <a href="migration.html#upgrading-targets-for-sdk-41">Upgrading targets for SDK 4.1</a>
            
        </li>
    
        <li>
            <a href="migration.html#migrating-targets-from-sdk-1x">Migrating targets from SDK 1.x</a>
            
        </li>
    
</ul>

            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-android-release-notes">Wikitude SDK Android Release Notes</a>
            
                
    <ul>
    
        <li>
            <a href="changelog.html#wikitude-sdk-5">Wikitude SDK 5</a>
            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-41">Wikitude SDK 4.1</a>
            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-40">Wikitude SDK 4.0</a>
            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-33">Wikitude SDK 3.3</a>
            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-32">Wikitude SDK 3.2</a>
            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-31">Wikitude SDK 3.1</a>
            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-30">Wikitude SDK 3.0</a>
            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-20">Wikitude SDK 2.0</a>
            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-12">Wikitude SDK 1.2</a>
            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-11">Wikitude SDK 1.1</a>
            
        </li>
    
        <li>
            <a href="changelog.html#wikitude-sdk-10">Wikitude SDK 1.0</a>
            
        </li>
    
</ul>

            
        </li>
    
</ul>

    </nav>
    
    <nav id="links">
        <ul>
            
        </ul>
    </nav>
    
    </div>
</div>
        <div id="content">
            <h1 id="getting-started">Getting started</h1>
<p class='intro' markdown='1'>Welcome to the Wikitude SDK. This document is designed to help you from your very first steps with the Wikitude SDK all the way through to advanced concepts and examples for developing your augmented reality project.</p>

<h3 id="recommended-usage-of-this-documentation">Recommended Usage of this Documentation</h3>
<p>The documentation is arranged in a way to guide you through the various steps in your development process. We recommend  following each of the steps outlined below and reading the documentation in the order displayed.</p>
<div class="bigNumbers" markdown='1'>
<div class='number'>1</div>
<h4 id="-setup-your-project-setupguideandroid-html-"><a href="setupguideandroid.html">Setup your project</a></h4>
<p>In this section we describe the necessary steps to setup a project in a detailed guide.</p>
<div class='number'>2</div>
<h4 id="-view-the-samples-samples-html-"><a href="samples.html">View the samples</a></h4>
<p>All of the included samples are complete augmented reality experiences which run in <code>SDKExamples</code> app. Browse through this section and get an idea of what the SDK is capable of.The relevant parts of the samples are described in more detail to highlight the applied concepts and patterns. These examples are designed to help you get off to a great start with the Wikitude SDK.</p>
<p>Viewing samples based on vision based augmented reality requires the corresponding reference images. All of them are available directly in the description of the sample or available as a collection <a href="targetimages.html">on this page</a>, which you can either view on the screen or print.</p>
<div class='number'>3</div>
<h4 id="-write-your-own-architect-world-workflow-html-"><a href="workflow.html">Write your own Architect World</a></h4>
<p>This section will introduce you to best practices for your development workflow once you write your own code for your augmented reality experience.</p>
<div class='number'>4</div>
<h4 id="-get-good-at-what-you-do-tools-html-"><a href="tools.html">Get good at what you do</a></h4>
<p>The Wikitude SDK comes with several tools which help you to develop more complex augmented reality experiences. This section covers how to use these tools and how they will assist you in your daily work.
</div></p>
<h3 id="the-wikitude-sdk-augmented-reality-for-your-own-app">The Wikitude SDK - Augmented Reality for your own app</h3>
<p>The Wikitude SDK is a software library and framework for mobile apps used to create augmented reality experiences. The SDK supports any kind of location based use case as well as use cases which require image recognition and tracking technology (vision based augmented reality). </p>
<h3 id="architecture-of-the-wikitude-sdk">Architecture of the Wikitude SDK</h3>
<p><img src="images/WikitudeSDK_architecture_v5.png" alt=""></p>
<p>The image above shows the different components of the Wikitude SDK and possible approaches for creating augmented reality apps. Each of these approaches is based on a certain development environments (IDE) and platforms:</p>
<ul>
<li><strong>Computer Vision Engine:</strong> The computer vision engine is a core component of the Wikitude SDK and used by all platforms. It is not directly accessible, but wrapped either by the Native API or the JavaScript API.</li>
<li><strong>Wikitude SDK  - Native API:</strong> Provides access to the Wikitude computer vision engine natively for Android (Java) and iOS (ObjC). It also can load plugins via the Wikitude Plugins API. (NOTE: Wikitude SDK plugins have nothing to do with the Cordova or Unity Plugin concept.)</li>
<li><strong>Wikitude SDK  - JavaScript API:</strong> Allows to build augmented reality worlds on basis of HTML and JavaScript. It is available for Android and iOS. The JavaScript API provides access to the functionality of the computer vision engine, location based AR, the Plugins API and dedicated rendering functionality.</li>
<li><strong>Wikitude SDK  - Plugins API:</strong> An API to connect your own plugins to the Wikitude SDK.</li>
<li><strong>Wikitude SDK  - Cordova Plugin:</strong> On top of the JavaScript API the Cordova plugin allows to use the Wikitude SDK in combination with Apache Cordova.</li>
<li><strong>Wikitude SDK  - Titanium Module:</strong> On top of the JavaScript API the Titanium module allows to use the Wikitude SDK in combination with Titanium.</li>
<li><strong>Wikitude SDK  - Unity Plugin:</strong> On top of the Native API the Unity plugin allows to use the Wikitude SDK in combination with Unity.</li>
<li><strong>Wikitude SDK  - Xamarin Component:</strong> On top of the JavaScript API the Cordova plugin allows to use the Wikitude SDK in combination with Xamarin.</li>
</ul>
<h3 id="how-to-code-for-the-wikitude-sdk">How to code for the Wikitude SDK</h3>
<p>The Wikitude SDK builds heavily on web technologies (HTML, JavaScript, CSS) to allow developers to write cross platform augmented reality experiences. These augmented reality experiences are called ARchitect worlds and are basically ordinary HTML pages that can utilize the ARchitect API to create objects in augmented reality.</p>
<p>Integrating the Wikitude SDK into your application is done by adding the platform specific view component called <code>ARchitectView</code> to your applications user interface. See the setup guide for how to setup a native project and load an ARchitect World.</p>
<p>Get started with writing augmented reality experiences by viewing through the examples included in the SDK. Each example is explained in detail in this documentation. Additional information about the ARchitect API can be found in the included API specification.</p>
<h3 id="the-wikitude-developer-portal">The Wikitude Developer Portal</h3>
<p>The <a href="http://www.wikitude.com" target="_top">Wikitude Developer Section</a> should be your first stop when you have specific development related questions. The portal hosts a very active <a href="http://www.wikitude.com/developer/developer-forum" target="_top">Developer Community Forum</a> where Wikitude staff members are constantly assisting other developers with helpful tips and advice. A <a href="http://www.wikitude.com/developer/knowledge-base" target="_top">Knowledge Base</a> helps with various questions.</p>
<h3 id="feedback-and-contact">Feedback and Contact</h3>
<p>We are always interested in your feedback and suggestions how we can improve this documentation. Please use the <a href="http://www.wikitude.com/contact" target="_top">contact form</a> on our website or visit us on <a href="https://plus.google.com/103004921345651739447/" target="_top">Google+</a> or <a href="http://www.facebook.com/WIKITUDE" target="_top">Facebook</a></p>

<h2 id="setup-guide-android">Setup Guide Android</h2>
<h3 id="project-setup-android-studio">Project Setup Android Studio</h3>
<p>This guide uses Android Studio, if for some reason you can&#39;t use Android Studio yet, please refer to the guide below on how to setup an Eclipse project. Please note that Eclipse support is deprecated with Wikitude SDK 5.0 release and won&#39;t be supported in future versions.</p>
<ul>
<li><p>Create a new <a href="http://developer.android.com/training/basics/firstapp/creating-project.html" target="_top">Android Application Project</a> (There is also a working SampleProject bundled in this SDK, where all these steps are already made)</p>
</li>
<li><p>Copy the file <code>libs/wikitudesdk.aar</code> into the libs folder of your module. (project root/app/libs)</p>
</li>
<li><p>Open <code>build.gradle</code> from your module, add the <code>wikitudesdk.aar</code> as a dependency and tell gradle to search the libs folder, like in the code below.</p>
</li>
</ul>
<pre><code>android {
    ...
}

dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    compile (name: &#39;wikitudesdk&#39;, ext:&#39;aar&#39;)
    compile &#39;com.android.support:appcompat-v7:21.0.3&#39;
}

repositories {
    flatDir{
        dirs &#39;libs&#39;
    }
}
</code></pre><ul>
<li>If you already purchased a license, please set the applicationId to the package name you provided us with.</li>
</ul>
<pre><code class="lang-xml">    defaultConfig {
        applicationId &quot;xxxx&quot;
    }
</code></pre>
<ul>
<li>Add the following permissions to your AndroidManifest.xml</li>
</ul>
<pre><code class="lang-xml">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_GPS&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.location&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.sensor.accelerometer&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.sensor.compass&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-sdk android:targetSdkVersion=&quot;19&quot; android:minSdkVersion=&quot;9&quot;/&gt;
</code></pre>
<ul>
<li>The activity holding the AR-View (called <code>architectView</code> in the following) must have set <code>android:configChanges=&quot;screenSize|orientation&quot;</code> in the <code>AndroidManifest.xml</code>,
for example this could look like:</li>
</ul>
<pre><code>&lt;activity android:name=&quot;com.yourcompany.yourapp.YourArActivity&quot;
   android:configChanges=&quot;screenSize|orientation&quot;/&gt;
</code></pre><ul>
<li>Enter a valid trial license key. Read this chapter on how to <a href="triallicense.html">obtain a free trial key</a>.</li>
</ul>
<h3 id="project-setup-eclipse">Project Setup Eclipse</h3>
<p>Please note that Eclipse support is deprecated with Wikitude SDK 5.0 release and won&#39;t be supported in future versions.</p>
<ul>
<li>Create a new <a href="http://developer.android.com/tools/projects/projects-eclipse.html#CreatingAProject" target="_top">Android Application Project</a> (There is also a working SampleProject bundled in this SDK, where all these steps are already made)</li>
<li>Create a <code>libs</code> folders in your project root directory and copy <code>libs/wikitudesdk.jar</code></li>
<li><p>In Eclipse enter <code>Preferences</code> -&gt; <code>Android</code> -&gt; <code>Build</code> and ensure the option <code>Force error when external jars contain native libraries</code> is unchecked</p>
<p>  <img src="images/android_setup_nativelib.png" alt="External jar contains native libraries"></p>
</li>
<li><p>Add the following permissions to your Manifest.xml</p>
</li>
</ul>
<pre><code class="lang-xml">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_GPS&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.location&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.sensor.accelerometer&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.sensor.compass&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-sdk android:targetSdkVersion=&quot;19&quot; android:minSdkVersion=&quot;9&quot;/&gt;
</code></pre>
<ul>
<li>The activity holding the AR-View (called <code>architectView</code> in the following) must have set <code>android:configChanges=&quot;screenSize|orientation&quot;</code> in the <code>AndroidManifest.xml</code>,
for example this could look like:</li>
</ul>
<pre><code>&lt;activity android:name=&quot;com.yourcompany.yourapp.YourArActivity&quot;
   android:configChanges=&quot;screenSize|orientation&quot;/&gt;
</code></pre><ul>
<li>Enter a valid trial license key. Read this chapter on how to <a href="triallicense.html">obtain a free trial key</a>.</li>
</ul>
<h3 id="ar-view-in-activity">AR View in Activity</h3>
<p>Keep in mind that the Wikitude SDK is not a native Android SDK as you know from other SDK&#39;s. The basic concept is to add an <code>architectView</code> to your project and notify it about lifecycle events. The <code>architectView</code> creates a camera surface and handles sensor events.
The experience itself, sometime referred to as ARchitect World, is implemented in JavaScript and packaged in your application&#39;s asset-folder (as in this project) or on your own server.
The experiences are written in HTML and JavaScript and call methods in Wikitude&#39;s <code>AR</code>-namespace (e.g. <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a>). </p>
<p>You have to include </p>
<pre><code> &lt;script src=&quot;architect://architect.js&quot;&gt;&lt;/script&gt;
</code></pre><p>in your HTML files to use the <code>AR</code> namespace and the <code>architectView</code> will handle them properly. To test an ARchitect World on a desktop browser, you must include <code>ade.js</code> tool instead to avoid JavaScript errors and see a development console.  </p>
<p>It is recommended to handle your augmented reality experience in a separate <a href="http://developer.android.com/reference/android/app/Activity.html" target="_top">Activity</a>. 
Declare the <code>architectView</code> inside a <a href="http://developer.android.com/guide/topics/ui/declaring-layout.html" target="_top">layout XML</a>.
E.g. Add this within <a href="http://developer.android.com/reference/android/widget/FrameLayout.html" target="_top">FrameLayout</a>&#39;s parent tags.</p>
<pre><code>&lt;com.wikitude.architect.ArchitectView android:id=&quot;@+id/architectView&quot;
   android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;/&gt;
</code></pre><p>ArchitectView is creating a camera surface so ensure to properly <a href="http://developer.android.com/reference/android/hardware/Camera.html" target="_top">release the camera</a> in case you&#39;re using it somewhere else in your application. 
Besides a camera (front or back-facing) the ArchitectView also makes use of compass and accelerometer values, requires <a href="http://www.khronos.org/opengles/2_X/" target="_top">OpenGL 2.0</a> and at least Android 4.0.
<code>ArchitectView.isDeviceSupported(Context context)</code> checks whether the current device has all required hard- and software in place or not.</p>
<div class="tip">
Note: Make AR-View only accessible to supported devices
</div>

<p>It is very important to notify the <code>ArchitectView</code> about <a href="http://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle" target="_top">life-cycle events</a> of the Activity.
Call architectView&#39;s <code>onCreate(), onPostCreate(), onPause(), onResume(), onDestroy()</code> inside your Activity&#39;s lifecycle methods.
Best practice is to define a member variable for the <code>architectView</code> in your Activity. Set it right after <code>setContentView</code>in Activity&#39;s <code>onCreate()</code>, and then access <code>architectView</code> via member-variable later on.</p>
<pre><code>this.architectView = (ArchitectView)this.findViewById( R.id.architectView );
final StartupConfiguration config = new StartupConfiguration( * license key */ );
this.architectView.onCreate( config );
</code></pre><p>Activity&#39;s <code>onPostCreate()</code> is the best place to load the AR experience.</p>
<pre><code>this.architectView.onPostCreate();
this.architectView.load( &quot;YOUR-AR-URL&quot; );
</code></pre><p>The <code>architectView.load()</code> argument is the path to the html file that defines your AR experience. It can be relative to the asset folder root or a web-url (starting with <code>http://</code> or <code>https://</code>).
e.g. <code>architectView.load(&#39;arexperience.html&#39;)</code> opens the html in your project&#39;s <code>assets</code>-folder, whereat <code>architectView.load(&#39;http://your-server.com/arexperience.html&#39;)</code> loads the file from a server.</p>
<div class="tip">
Note: You can only pass arguments to the html file when loading it via url. The following will not work: <br><br>
    <code>architectView.load(&#39;arexperience.html?myarg=1&#39;)</code>
</div>

<h3 id="location">Location</h3>
<p>Management of the location is important in  location based augmented reality applications. Depending on the use-case location is used via GPS or network and may be updated every second or once in a while.
Although the SDKExamples project provides a basic implementation of a <code>LocationProvider</code> this is by far not the best <a href="http://developer.android.com/guide/topics/location/strategies.html" target="_top">location strategy</a> available for Android.</p>
<p><strong>Please use your own advanced location strategy implementation in case you have special requirements</strong>.</p>

<h2 id="supported-android-devices">Supported Android Devices</h2>
<p>Wikitude SDK is running on devices fulfilling the following requirements:</p>
<table>
<tr>
<th></th>
<th style="width:42%;">Sensor-based AR (Geo-AR)</th>
<th style="width:42%;">Image recognition and tracking</th>
</tr>
<tr>
<td><a name="supporteddevicesandroid"></a><strong>Android</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Android 4.0+ (API Level 14+)</li>
 <li>Compass</li>
 <li>GPS and / or network positioning</li>
 <li>Accelerometer</li>
 <li><a href="http://developer.android.com/guide/practices/screens_support.html" target="_top">High resolution devices (hdpi)</a></li>
 <li>Rear-facing camera</li>
 <li><a href="http://developer.android.com/guide/topics/graphics/opengl.html" target="_top">OpenGL 2.0</a></li>
 </ul>

</td>
<td style="vertical-align:top;">
 <ul>
 <li>Android 4.0+ (API Level 14+)</li>
  <li><a href="http://developer.android.com/guide/practices/screens_support.html" target="_top">High resolution devices (hdpi)</a></li>
   <li>Rear-facing camera</li>
 <li>Devices with a capable CPU (armv7a and NEON support) e.g.</li>
 <ul><li>Samsung Galaxy S2 or newer</li>
 <li>Nexus 4 or newer</li>
 <li>Nexus 10 (2012) or newer</li>
</ul>
 </ul>

</td>
</tr>

</table>

<p>Requirements for other operating systems and platforms are listed in <a href="supporteddevices.html">this overview</a>.</p>

<h4 id="supported-devices">Supported Devices</h4>
<p>Wikitude SDK is running on devices fulfilling the following requirements:</p>
<table>
<tr>
<th></th>
<th style="width:42%;">Sensor-based AR (Geo-AR)</th>
<th style="width:42%;">Image recognition and tracking</th>
</tr>
<tr>
<td><a name="supporteddevicesandroid"></a><strong>Android</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Android 4.0+ (API Level 14+)</li>
 <li>Compass</li>
 <li>GPS and / or network positioning</li>
 <li>Accelerometer</li>
 <li><a href="http://developer.android.com/guide/practices/screens_support.html" target="_top">High resolution devices (hdpi)</a></li>
 <li>Rear-facing camera</li>
 <li><a href="http://developer.android.com/guide/topics/graphics/opengl.html" target="_top">OpenGL 2.0</a></li>
 </ul>

</td>
<td style="vertical-align:top;">
 <ul>
 <li>Android 4.0+ (API Level 14+)</li>
  <li><a href="http://developer.android.com/guide/practices/screens_support.html" target="_top">High resolution devices (hdpi)</a></li>
   <li>Rear-facing camera</li>
 <li>Devices with a capable CPU (armv7a and NEON support) e.g.</li>
 <ul><li>Samsung Galaxy S2 or newer</li>
 <li>Nexus 4 or newer</li>
 <li>Nexus 10 (2012) or newer</li>
</ul>
 </ul>

</td>
</tr>
<tr>
<td><a name="supporteddevicesepson"></a><strong>Epson</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Epson Moverio BT-200</li>
 </ul>

</td>
<td style="vertical-align:top;">
 <ul>
 <li>Epson Moverio BT-200</li>
 </ul>
</td>
</tr>
<tr>
<td><a name="supporteddevicesglass"></a><strong>Google Glass</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Google Glass</li>
 </ul>

</td>
<td style="vertical-align:top;">
 <ul>
 <li>Google Glass</li>
 </ul>
</td>
</tr>

<tr>
<td><a name="supporteddevicesios"></a><strong>iOS</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Devices running iOS 7.0  and up</li>
 <li>Compass</li>
 <li>GPS and / or network positioning</li>
 <li>Accelerometer</li>
 <li>Rear-facing camera</li>
 </ul>
 </td>
<td style="vertical-align:top;">
 <ul>
  <li>Devices running iOS 7.0  and up</li>
  <li>Rear-facing camera</li>
 <li>Devices with a capable CPU (minimum Apple A4 SoC) e.g.</li>
 <ul><li>iPhone 4 or newer</li>
 <li>iPad2 or newer</li>
 <li>iPod Touch 5th gen</li></ul>
 </ul>
</td>
</tr>
<tr>
<td><a name="supporteddevicesvuzix"></a><strong>Vuzix</strong></td>
<td style="vertical-align:top;">
 <ul>
 <li>Vuzix M100</li>
 </ul>

</td>
<td style="vertical-align:top;">
 <ul>
 <li>Vuzix M100</li>
 </ul>
</td>
</tr>
</table>

<h2 id="how-to-obtain-a-free-trial-license">How to obtain a free trial license</h2>
<p>The Wikitude SDK requires a valid license key to be able to run properly. An empty or missing license key will block the augmented reality view from showing any meaningful content. You will see a watermark across the screen with the words <code>License Key Missing</code>. All JavaScript API calls will be ignored and not interpreted.</p>
<p>When downloading the Wikitude SDK you will be forwarded to the <a href="http://www.wikitude.com/developer/licenses">license generation page</a>, where a trial license key is automatically generated for you. </p>
<p><img src="images/trial_key_license_page.png" alt=""></p>
<p>Copy the key into your app, which will unlock the trial mode of the Wikitude SDK. The trial mode of the Wikitude SDK contains the full feature set of the Wikitude SDK but will show a <code>Trial</code> watermark across the screen.</p>
<p>Each trial license key is valid for every application ID on every operating system. You can use the same trial license key in multiple apps. </p>
<h2 id="where-should-i-enter-the-license-key">Where should I enter the license key</h2>
<h3 id="android">Android</h3>
<p>To use the Wikitude Android SDK you need to provide a valid license key to the <code>onCreate</code> lifecycle-method of the ArchitectView. This can either be done directly by providing the key as a string and the call the <code>onCreate(final String key)</code> method or creating an <code>StartupConfiguration</code> object, passing it the license as a string and then call the <code>onCreate(final StartupConfiguration config)</code> method. Please refer to the <code>AbstractArchitectCamActivity</code> of the SDK Examples project for a practical example of how to set the license key. </p>

<h1 id="examples">Examples</h1>
<p>The following examples should give you an overview of the capabilities offered by the Wikitude SDK. Each sample is capable of running without modifications on all supported platforms. </p>
<p>Each of the included examples is structured as following:</p>
<ul>
<li><code>index.html</code>: entry point for the experience</li>
<li><code>js/*</code>: includes the necessary JavaScript files</li>
<li><code>css/*</code>: css style sheets required</li>
<li><code>assets/*</code>: contains images, 3D models and tracker files</li>
</ul>
<p>Inside the <code>js/</code> folder the main JavaScript file is named like the example. (the example <em>Image Recognition</em> has its JavaScript code in the <code>js/clientrecognition.js</code> file). Code which is mentioned in the description of the examples can be found in this file, if not explicitly stated otherwise.</p>
<h3 id="samples-on-github">Samples on GitHub</h3>
<p>If you are just interested in browsing through the code of the augmented reality experience you can also find the entire source code of the samples on <a href="https://github.com/Wikitude/wikitude-sdk-samples" target="_top">GitHub</a></p>
<h3 id="android-sdk-examples">Android SDK Examples</h3>
<p>This section describes the <code>SDK Sample</code> project in detail and highlights the main features and use-cases of the Wikitude SDK.
The project is part of the SDK bundle and is an Android Studio project, ready to run on any of the supported Android devices.</p>
<p><em>Note: You cannot run Wikitude SDK project on Android Emulator due to OpenGL restrictions.</em></p>
<p>Run through the setup guide, install the sample project on your device and scroll through the sample list.</p>
<p>The project&#39;s <code>asset</code> folder contains implementation of the various ARchitect Worlds. 
Implementation of the native Android activities is available in the <code>src</code> folder. </p>
<h3 id="setup">Setup</h3>
<ul>
<li>Download latest <a href="https://developer.android.com/sdk/index.html" target="_top">Android SDK</a> through the Android Studio Bundle (either Mac OS or Windows)</li>
<li>From the main menu select <code>Open an existing Android Studio project</code> which will open the import wizard.</li>
<li>Navigate to the <code>SDKExamples</code> project folder in your filesystem.</li>
<li>Click <code>Finish</code> to start the import.</li>
<li>Right click the project folder, click <code>Preferences</code> and <code>Android</code></li>
<li><p>Ensure you have very latest SDK (14+) checked in the Build Target list</p>
<p><img src="images/android_sdk_version.png" alt="Project Build Targets"></p>
</li>
<li><p>Use an Android device that has all hard- and software requirements (see <a href="SupportedDevicesAndroid.html">Supported Devices</a>) and <a href="http://support.google.com/coordinate/bin/answer.py?hl=en&answer=2569281" target="_top">enable your location services in system settings</a></p>
</li>
<li>Enter <code>Settings</code> -&gt; <code>Applications</code> -&gt; <code>Developer</code> -&gt; check <code>USB debugging</code></li>
<li>Plug in the device via USB.</li>
<li>Right click the project folder again select <code>Run as…</code> - <code>Android Application</code> and select the target device</li>
<li>The sample application is then installed onto your device</li>
</ul>
<h3 id="communication-between-javascript-and-android-native-java-">Communication between JavaScript and Android Native (Java)</h3>
<p>The samples mainly describe  how to launch an AR experience in your Android activity - anything relevant for AR is written in the provided HTML and JavaScript file.</p>
<p>Although it is highly recommended to implement logic in pure HTML and JavaScript at some point in time it makes sense to interact between native Android and the JavaScript of your AR experience.</p>
<p>One may for instance pass data for points of interest (POI) from native Android to JavaScript. 
Define a method named <code>newData(json)</code> in the JavaScript file and use <code>architectView.callJavascript(newData(&#39;&quot; + poiDataAsJson +&quot;)&#39;)</code> to call the method and pass over the values properly. <a href="http://www.json.org/" target="_top">JSON Format</a> is the fastest way to pass bulk of information, like translations, metadata and POI information over to your JavaScript. 
There are several ways to <a href="http://developer.android.com/reference/org/json/package-summary.html" target="_top">create a JSON in Android</a>.</p>
<p>Sometimes events like a click in your AR experience should cause a reaction in native Android, like launching another screen when clicking a placemark or image target. To achieve that you   need to register a <code>urlListener</code> using <code>architectView.registerUrlListener()</code> in the activity.
Any <code>document.location</code> changes to <code>architectsdk://</code> will fire an event in your listener (e.g. <code>document.location = architectsdk://YOUR-INFO</code>). Listener is informed about the invoked url and can then react on.</p>
<p><em>Note: Missing urlListener registration will cause an HTTP error when calling <code>document.location = architectsdk://YOUR-INFO</code></em></p>

<h2 id="client-recognition">Client Recognition</h2>
<p>This example shows how to recognize images in the viewfinder and overlay it with images. Furthermore it shows how to recognize multiple different images and how to react on user clicks on the overlaid elements.</p>
<p>For a better understanding, here are some terms that will be used in the following and other section of this documentation related to vision-based augmented reality.</p>
<ul>
<li><p><strong>Target</strong>: A target image and its associated extracted data that is used by the tracker to recognize an image.</p>
</li>
<li><p><strong>Target collection</strong>: An archive storing a collection of targets that can be recognized by the tracker. A target collection can hold up to 1000 targets.</p>
</li>
<li><p><strong>ClientTracker</strong>: The tracker analyzes the live camera image and detects the targets stored in its associated target collection. Multiple trackers can be created, however only one tracker can be active for recognition at any given time.</p>
</li>
</ul>
<p>This sample consists of five parts</p>
<ol>
<li><a href="#imageontarget">Image on Target</a></li>
<li><a href="#multipletarget">Multiple Targets</a></li>
<li><a href="#extendedtracking">Extended Tracking</a></li>
<li><a href="#interactivity">Interactivity</a></li>
<li><a href="#htmldrawables">Adding HTML content</a></li>
<li><a href="#bonussparkle">Bonus: Sparkle Animations</a></li>
<li><a href="#distancetotarget">Bonus: Distance to target</a></li>
</ol>
<p><a id="imageontarget"></a></p>
<h3 id="image-on-target-1-7-">Image on Target (1/7)</h3>
<p>With these terms in mind let&#39;s start by defining what actually should be recognized (target) and create a corresponding target collection that the tracker can use. In this case, the target collection includes the following single magazine page.</p>
<p>To view the sample you can use the image in <a href="targetimages.html">on this page</a></p>
<p><img src="images/magazine_page_one.jpeg" alt="Page of a magazine that should be augmented." title="Page of a magazine that should be augmented"></p>
<p>See <a href="targetmanagement.html">Target Management</a> for instructions about how to create target collections which can be used in the Wikitude SDK.</p>
<p>This is the same process for every use of image recognition in ARchitect. You&#39;ll first need to define your targets and then create a target collection for it. Now let us have a look at the JavaScript for enabling image recognition.</p>
<pre><code class="lang-js">// Initialize ClientTracker
// Important: If you replace the tracker file with your own, make sure to change the target name accordingly.
// Use a specific target name to match only a certain target or use a wildcard to match any or a certain group of targets.

this.tracker = new AR.ClientTracker(&quot;assets/magazine.wtc&quot;, {
    onLoaded: this.worldLoaded
});

// Create overlay for page one
var imgOne = new AR.ImageResource(&quot;assets/imageOne.png&quot;);
var overlayOne = new AR.ImageDrawable(imgOne, 1, {
    offsetX: -0.15,
    offsetY: 0
});

var pageOne = new AR.Trackable2DObject(this.tracker, &quot;*&quot;, {
    drawables: {
        cam: overlayOne
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_1_ImageOnTarget/js/imageontarget.js#L19-L41">GitHub</a>
</div>

<p>First an  <a href="../Reference/JavaScript%20API/classes/ClientTracker.html"><code>AR.ClientTracker</code></a> needs to be created in order to start the recognition engine. It is initialized with a URL specific to the target collection. Optional parameters are passed as object in the last argument. In this case a callback function for the <a href="../Reference/JavaScript%20API/classes/ClientTracker.html#event_onLoaded"><code>onLoaded</code></a> trigger is set. Once the tracker is fully loaded the function <code>worldLoaded()</code> is called.</p>
<p>The next step is to create the augmentation. In this example an image resource is created and passed to the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a>. A drawable is a visual component that can be connected to an target image  <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> or a geolocated object  <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a>. The <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> is initialized by the image and its size. Optional parameters allow for position it relative to the recognized target.</p>
<p>The last line combines everything by creating an <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> with the previously created tracker, the name of the image target and the drawable that should augment the recognized image.
Please note that in this case the target name is a wildcard <code>*</code>. Wildcards can be used to match any target defined in the target collection. If you want to match specific targets only for a particular <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> simply provide the target name as specified in the target collection.</p>
<div class="warning"> 
<strong>Recognize your own images</strong>

 <ol>
 <li>Upload your images to the <a href="http://www.wikitude.com/developer/tools/target-manager" target="_top">target management tool (log-in required)</a></li>
 <li>Generate your target collection file (.wtc)</li>
 <li>In your code create an  <code>AR.ClientTracker</code> and load the target collection file from the previous step</li>
 <li>Create an AR.Trackable2DObject and assign <strong>your</strong> targetName</li>
 </ol>
<br />

Make sure that the <code>targetName</code> used with the <code>AR.Trackable2DObject</code> correspond to one of the target names in your target collection. You can also use a wildcard to match any target or only a specific subset of targets. Please refer to the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> main documentation for more information about wildcards.

</div>

<p><a id="multipletarget"></a></p>
<h3 id="multiple-targets-2-7-">Multiple Targets (2/7)</h3>
<p>Adding multiple targets to a target collection is straightforward. Simply follow the guide at <a href="targetmanagement.html">Target Management</a>. Each target in the target collection is identified by its <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html#property_targetName"><code>targetName</code></a>. By using this <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html#property_targetName"><code>targetName</code></a>, it is possible to create an <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> for every target in the target collection.</p>
<p>To view the sample you can use the image in <a href="targetimages.html">on this page</a></p>
<p><img src="images/magazine_page_two.jpeg" alt="Second page of a magazine that should be augmented." title="Second page of a magazine that should be augmented."></p>
<pre><code class="lang-js">// Create overlay for page two
var imgTwo = new AR.ImageResource(&quot;assets/imageTwo.png&quot;);
var overlayTwo = new AR.ImageDrawable(imgTwo, 0.5, {
    offsetX: 0.12,
    offsetY: -0.01
});
var pageTwo = new AR.Trackable2DObject(this.tracker, &quot;pageTwo&quot;, {
    drawables: {
        cam: overlayTwo
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_2_MultipleTargets/js/multipletargets.js#L48-L61">GitHub</a>
</div>

<p>Similar to the first part, the image resource and the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> for the second overlay are created. The <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> for the second page uses the same tracker but with a different target name.</p>
<p><a id="extendedtracking"></a></p>
<h3 id="extended-tracking-3-7-">Extended Tracking (3/7)</h3>
<p>Extended tracking is an optional mode you can set for each <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> separately. In this mode the Wikitude SDK will scan the environment of the user and try to keep track of the scene even if the original target image is not in view anymore. So the tracking extends beyond the limits of the original target image. The performance of this feature depends on various factors like computing power of the device, background texture and objects.</p>
<p>If a target is enabled for extended tracking the <code>onExitFieldOfVision</code> trigger is not called when the original target image is not visible anymore, but once the extended tracking is interrupted. </p>
<p>If you don&#39;t need this feature, we recommend not to enable it to avoid high CPU load.</p>
<p>In the sample the <code>AR.Trackable2DObject</code> is defined as usual with the difference that the option <code>enableExtendedTracking</code> is set to <code>true</code>.</p>
<p>If you need informations about the quality of the extended tracking, you must define the callback function <code>onExtendedTrackingQualityChanged</code> like in the example below.</p>
<pre><code class="lang-js">        var pageOne = new AR.Trackable2DObject(this.tracker, &quot;*&quot;, {
            drawables: {
                cam: [pipes]
            },
            enableExtendedTracking: true,
            onExtendedTrackingQualityChanged: function (targetName, oldTrackingQuality, newTrackingQuality) {
                var backgroundColor;
                var trackingQualityText;

                if ( -1 == newTrackingQuality ) {
                    backgroundColor = &#39;#FF3420&#39;;
                    trackingQualityText = &#39;Bad&#39;;
                } else if ( 0 == newTrackingQuality ) {
                    backgroundColor = &#39;#FFD900&#39;;
                    trackingQualityText = &#39;Average&#39;;
                } else {
                    backgroundColor = &#39;#6BFF00&#39;;
                    trackingQualityText = &#39;Good&#39;;
                }
                var cssDivInstructions = &quot; style=&#39;display: table-cell;vertical-align: middle; text-align: middle; width: 50%; padding-right: 15px;&#39;&quot;;
                var messageBox = document.getElementById(&#39;loadingMessage&#39;);
                messageBox.style.backgroundColor = backgroundColor;
                messageBox.innerHTML = &quot;&lt;div&quot; + cssDivInstructions + &quot;&gt;Tracking Quality: &quot; + trackingQualityText + &quot;&lt;/div&gt;&quot;;
                messageBox.style.display = &#39;block&#39;;
            }
        });
</code></pre>
<p>With that enabled the tracking will continue even if the target image is lost.</p>
<p><a id="interactivity"></a></p>
<h3 id="interactivity-4-7-">Interactivity (4/7)</h3>
<p>The final step is to add interactivity to the image target. For this example a button is added to each target that opens a webpage.</p>
<p>The button is created similar to the overlay feature. An <a href="../Reference/JavaScript%20API/classes/ImageResource.html"><code>AR.ImageResource</code></a> defines the look of the button and is reused for both buttons.</p>
<pre><code>this.imgButton = new AR.ImageResource(&quot;assets/wwwButton.png&quot;);
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_3_Interactivity/js/interactivity.js#L28">GitHub</a>
</div>

<p>For each target an <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> for the button is created by utilizing the helper function <code>createWwwButton(url, options)</code>. The returned drawable is then added to the <code>drawables.cam</code> array on creation of the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>.</p>
<pre><code class="lang-js">var pageOneButton = this.createWwwButton(&quot;http://www.wikitude.com/pageone&quot;, 0.1, {
    offsetX: -0.25,
    offsetY: -0.25
});
var pageOne = new AR.Trackable2DObject(this.tracker, &quot;pageOne&quot;, {
    drawables: {
        cam: [overlayOne, pageOneButton]
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_3_Interactivity/js/interactivity.js#L42-46">GitHub</a>
</div>

<p>As the button should be clickable the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html#event_onClick"><code>onClick</code></a> trigger is defined in the options passed to the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a>. In general each drawable can be made clickable by defining its <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html#event_onClick"><code>onClick</code></a> trigger.</p>
<pre><code class="lang-js">createWwwButton: function createWwwButtonFn(url, size, options) {
    options.onClick = function() {
        AR.context.openInBrowser(url);
    };
    return new AR.ImageDrawable(this.imgButton, size, options);
},
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_3_Interactivity/js/interactivity.js#L81-89">GitHub</a>
</div>

<p>The function assigned to the click trigger calls <a href="../Reference/JavaScript%20API/classes/context.html#method_openInBrowser"><code>AR.context.openInBrowser</code></a> with the specified URL, which opens the URL in the browser.</p>
<p><a id="htmldrawables"></a></p>
<h3 id="adding-html-content-5-7-">Adding HTML content (5/7)</h3>
<p>Using an <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html"><code>AR.HtmlDrawable</code></a> it is possible to display HTML content inside the AR scene, the same way images are displayed. In this example a weather widget is added on top of the image target to present the real-time weather in Maui, Hawaii.</p>
<p>In general any HTML content can be loaded by passing a relative or absolute URL. Additionally HTML content can also be passed as a string; please see the API reference for more details on how to specify the content when creating the drawable. This example uses a relative URL to the weather widget that is stored as <code>.html</code> file in the example&#39;s <code>assets</code> subfolder.</p>
<p>Once the content has been chosen it is important to think about the viewport the content will need in order to be laid out correctly. The viewport is the area that is available to the HTML content when it is rendered. It is independent of the actual area the <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html"><code>AR.HtmlDrawable</code></a> will need on screen when placed in the AR scene.</p>
<p>The viewport width and height needs to be set when constructing the <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html"><code>AR.HtmlDrawable</code></a> and should also be set as meta tag inside the  HTML content that is used. This tells the HTML rendering engine to use the specified viewport size during rendering.</p>
<pre><code class="lang-html">&lt;meta name=&quot;viewport&quot; 
      content=&quot;target-densitydpi=device-dpi, width = 320, user-scalable = 0&quot;&gt;
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_4_HtmlDrawable/assets/weather.html#L3">GitHub</a>
</div>

<p>Make sure that the value of <code>width</code> is set according to the size (in pixel) the HTML content needs. It should also correspond to the <code>viewportWidth</code> value specified during the creation of the <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html"><code>AR.HtmlDrawable</code></a>.</p>
<p>Similar to  <code>viewportWidth</code> the <code>viewportHeight</code> is specified to define the available pixel height during rendering of the content. If you are unsure of the pixel size of the HTML content at hand, you can use the developer tools built into modern browsers (e.g. WebInspector) to take measure.</p>
<p>In the code example below we are putting that all together to a working <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html"><code>AR.HtmlDrawable</code></a>. The created drawable is added to the list of <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> drawables just like any other drawable.</p>
<pre><code class="lang-js">var weatherWidget = new AR.HtmlDrawable({
    uri: &quot;assets/weather.html&quot;
}, 0.25, {
    viewportWidth: 320,
    viewportHeight: 100,
    backgroundColor: &quot;#FFFFFF&quot;,
    offsetX: +0.36,
    offsetY: 0.5,
    horizontalAnchor: AR.CONST.HORIZONTAL_ANCHOR.RIGHT,
    verticalAnchor: AR.CONST.VERTICAL_ANCHOR.TOP,
    clickThroughEnabled: true,
    allowDocumentLocationChanges: false,
    onDocumentLocationChanged: function onDocumentLocationChangedFn(uri) {
        AR.context.openInBrowser(uri);
    }
});
var pageOne = new AR.Trackable2DObject(this.tracker, &quot;pageOne&quot;, {
    drawables: {
        cam: [overlayOne, pageOneButton, weatherWidget, sparkles]
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_4_HtmlDrawable/js/htmldrawable.js#L68-L83">GitHub</a>
</div>

<p>Interaction with an <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html"><code>AR.HtmlDrawable</code></a> is controlled with the <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html#property_clickThroughEnabled"><code>clickThroughEnabled</code></a> and <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html#property_allowDocumentLocationChanges"><code>allowDocumentLocationChanges</code></a> properties. Setting <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html#property_clickThroughEnabled"><code>clickThroughEnabled</code></a> will forward click events to the HTML content making it possible to follow links or click buttons. If the content of the HTML drawable should not change <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html#property_allowDocumentLocationChanges"><code>allowDocumentLocationChanges</code></a> can be set to <code>false</code> so links are not followed. It is still possible to react on clicked links by using the <a href="../Reference/JavaScript%20API/classes/HtmlDrawable.html#event_onDocumentLocationChanged"><code>onDocumentLocationChanged</code></a> trigger. The example uses this trigger to open clicked links fullscreen in a browser. The result then looks like this</p>
<p><img src="images/IRExample_HTML_2.jpg" alt="HTML Drawable - Real time weather widget">
<a id="bonussparkle"></a></p>
<h3 id="bonus-sparkles-6-7-">Bonus: Sparkles (6/7)</h3>
<p>This section adds a little bonus to the above example. Sprite sheet animations can be used to animate images similar to animated GIFs and are used in this example to add sparkles to the overlay.</p>
<p>A sprite sheet is an image file that contains all key frame images required for the animation. The key frame image size (width and height) is passed at creation time and must be equal for all key frame images. Key frame images will be managed in an array, starting with entry 0. The key frame image array will be filled from left to right, row by row. Any partly filled key frames at the edge of the sprites sheet will be ignored.</p>
<p><img src="images/imageSparkles.png" alt="Sprite sheet of sparkles for this example." title="Sprite sheet of sparkles for this example."></p>
<p>First the image resource is created which is used for creating the <a href="../Reference/JavaScript%20API/classes/AnimatedImageDrawable.html"><code>AR.AnimatedImageDrawable</code></a>. Since the width/height of the sprite sheet is 512 and it carries 16 key frames, the width and height of a single image is 128. So we set 128 as the width and height of the <a href="../Reference/JavaScript%20API/classes/AnimatedImageDrawable.html"><code>AR.AnimatedImageDrawable</code></a>.</p>
<pre><code class="lang-js">// Sparkles
var imgSparkles = new AR.ImageResource(&quot;assets/imageSparkles.png&quot;);
var sparkles = new AR.AnimatedImageDrawable(imgSparkles, 0.25, 128, 128, {
    offsetX: -0.2,
    offsetY: 0.5,
    rotation: 75
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_5_Bonus-Sparkles/js/sparkles.js#L36-L41">GitHub</a>
</div>

<p>To start the animation the order of the keyframes needs to be passed as array. Additionally the time each frame is displayed in ms and the loop count needs to be defined. In this case each image is displayed 100ms before it changes and a loop count of <code>-1</code> plays the animation in an infinite loop.</p>
<pre><code class="lang-js">sparkles.animate([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], 100, -1);
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_5_Bonus-Sparkles/js/sparkles.js#L46">GitHub</a>
</div>

<p>The last step is to add it as drawable to the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> so it will be overlaid on the first page.</p>
<pre><code class="lang-js">var pageOne = new AR.Trackable2DObject(this.tracker, &quot;pageOne&quot;, {
    drawables: {
        cam: [overlayOne, pageOneButton, weatherWidget, sparkles]
    }
});
</code></pre>
<p><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_5_Bonus-Sparkles/js/sparkles.js#L106-110">GitHub</a>
</div>
<a id="distancetotarget"></a></p>
<h3 id="bonus-distance-to-target-7-7-">Bonus: Distance to target (7/7)</h3>
<p>This section shows how to measure the distance to a given target, and how to react to changes in the measured value.</p>
<p>The AR scene is based on the code of the first sample, with a target collection containing just one target.</p>
<p>We define the physical size of the target when creating the <a href="../Reference/JavaScript%20API/classes/ClientTracker.html"><code>ClientTracker</code></a>.</p>
<p>This is not always necessary, since a target collection can include the definition of the physical size for all targets (see <a href="targetmanagement.html">Target Management</a> for more details).</p>
<p>The <a href="../Reference/JavaScript%20API/classes/ClientTracker.html#property_physicalTargetImageHeights"><code>physicalTargetImageHeights</code></a> option is used for this purpose, with values in millimeters for each target.</p>
<p>For this example, we assume the target is printed on a standard A4 sheet with a physical height of 286mm, if your target size is different, change the value accordingly, otherwise the measurement won&#39;t be very accurate.</p>
<pre><code class="lang-js">         this.tracker = new AR.ClientTracker(&quot;assets/magazine.wtc&quot;, {
            onLoaded: this.worldLoaded,
            physicalTargetImageHeights: {
                pageOne:    286
            }
         });
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_6_Bonus-DistanceToTarget/js/distancetotarget.js#L13-L18">GitHub</a>
</div>

<p>Then we declare the callback function to be called when the distance changes, and the change threshold in millimeters to trigger the event:</p>
<pre><code class="lang-js">         var pageOne = new AR.Trackable2DObject(this.tracker, &quot;*&quot;, {
             drawables: {
                 cam: overlayOne
            },
            distanceToTarget: {
                changedThreshold: 1,
                onDistanceChanged: function(distance) {
                    document.getElementById(&#39;distanceDisplay&#39;).innerHTML = &quot;Distance from target: &quot; + distance / 10 + &quot; cm&quot;;
                    overlayOne.rotation = distance;
                }
            },
            onExitFieldOfVision: function() {
                document.getElementById(&#39;distanceDisplay&#39;).innerHTML = &quot;Distance from target: unknown&quot;;
             }
         });
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/1_ClientRecognition_6_Bonus-DistanceToTarget/js/distancetotarget.js#L35-L49">GitHub</a>
</div>

<p>The drawable definition is just the same as the first section.</p>
<p>The option <code>distanceToTarget</code> describes how the tracker will react to changes. The threshold is set to 1 millimeter, and the callback function displays the value on the bottom of the screen, and rotates the augmentation when the user moves towards the target or away from it. </p>
<p>We also define an <code>onExitFieldOfVision</code> trigger because we don&#39;t want to show any information when the target is not visible.</p>

<h2 id="cloud-recognition">Cloud Recognition</h2>
<p>This example shows how to recognize images on a cloud server and then overlay it with augmentations utilizing the <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a> class. </p>
<p>For a better understanding, here are some terms that will be used in the following and other sections of this documentation related to vision-based augmented reality.</p>
<ul>
<li><p><strong>Target</strong>: An image and its associated extracted data that is used to recognize an image.</p>
</li>
<li><p><strong>Target Collection</strong>: A group of <code>targets</code> that are searched together. Think of it as a directory, which contains all your images you want to search. The Wikitude SDK can work with two different sorts of <code>Target Collections</code></p>
<ul>
<li>On-device Target Collection: a static <code>wtc</code> file containing the extracted data of your images. Can consist of up to 1,000 images.</li>
<li>Cloud Target Collection: A target collection stored on the Wikitude server. See <code>Cloud Archive</code> below. Can consist of up to 50,000 images.</li>
</ul>
</li>
<li><p><strong>Cloud Archive</strong>: An archive stored on the server that is optimized for cloud-based recognition. It is generated from a <code>Target Collection</code> and is used in combination with <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>. </p>
</li>
<li><p><strong>CloudTracker</strong>: Instead of analysing and computing the live camera feed directly on the device like the <a href="../Reference/JavaScript%20API/classes/ClientTracker.html"><code>AR.ClientTracker</code></a>, the <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a> will send the image(s) taken by the camera to the Wikitude Cloud Recognition server. The server will then do the hard work of trying to match the image with your targets in the specified cloud archive. Beside the benefit of searching in large image database using the <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a> instead of <a href="../Reference/JavaScript%20API/classes/ClientTracker.html"><code>AR.ClientTracker</code></a> has also a positive impact on the general performance in most cases. Especially when using a large target collection and on older devices.</p>
</li>
</ul>
<p>This sample consists of three parts</p>
<ol>
<li><a href="#basicrecognitiononclick">Basic Recognition On-Click</a></li>
<li><a href="#continousvsonclick">Continuous Recognition vs On-Click</a></li>
<li><a href="#metainformation">Using MetaInformation in the response</a></li>
</ol>
<p>The sample is based on a use-case to recognize wine labels directly from wine bottles. We have set-up a target collection on the Wikitude server hosting several wine-labels from around the world. </p>
<p><a id="basicrecognitiononclick"></a></p>
<h3 id="basic-recognition-on-click-1-3-">Basic Recognition On-Click (1/3)</h3>
<p>The goal of this and the following samples in this section is to recognize and augment the wine labels in the image below. All three samples build on each other and functionality is added/improved in each sample.</p>
<p><img class="image_gallery" src="images/schloss_johannisberg.jpg"><img class="image_gallery" src="images/brazil.jpg"><img class="image_gallery" src="images/barone.jpg"><img class="image_gallery" src="images/etiquette_ermitage.jpg"><img class="image_gallery" src="images/gw_bf2011.jpg"></p>
<p>Please note that in this section a public cloud archive will be used. See the <a href="gettingstartedcloudrecognition.html">documentation for the Manager API</a> for instructions how to create your own cloud archives which can be used with the Wikitude SDK.</p>
<h4 id="regional-server-endpoints">Regional server endpoints</h4>
<p>Before we get started please note that you have to choose which regional-distributed Wikitude server the SDK should contact.</p>
<p>The cloud recognition server region can be selected by calling the <a href="../Reference/JavaScript%20API/classes/context.html#methodsetCloudRecognitionServerRegion"><code>AR.context.setCloudRecognitionServerRegion</code></a> function from JavaScript with on of the following constants.</p>
<pre><code>AR.CONST.CLOUD_RECOGNITION_SERVER_REGION.AMERICAS
AR.CONST.CLOUD_RECOGNITION_SERVER_REGION.CHINA
AR.CONST.CLOUD_RECOGNITION_SERVER_REGION.EUROPE
</code></pre><p>The default behaviour is <code>Europe</code>. In case of a wrong value the SDK will silently choose <code>Europe</code>.</p>
<p>Now let&#39;s get on with the first sample and have a look at the first part of the JavaScript code - the <code>init</code> function.</p>
<pre><code class="lang-js">    init: function initFn() {
        this.createTracker();
        this.createOverlays();
    },
</code></pre>
<p>Once the wine is recognized we want to display a banner which shows a rating, the wine label and in later chapters the name of the recognized wine to the end user. To keep this example simple we will reuse the same banner image on every target. Because of that we are able to load the image once and reuse again and again. This will be done in the <code>createOverlays</code> function, the second function call in the <code>init</code> function above.</p>
<pre><code class="lang-js">    createOverlays: function createOverlaysFn() {
        this.bannerImg = new AR.ImageResource(&quot;assets/banner.jpg&quot;);
        this.bannerImgOverlay = new AR.ImageDrawable(this.bannerImg, 0.4, {
            offsetX: 0,
            offsetY: -0.6,
        });
    },
</code></pre>
<p>First an image resource is created and then passed to an <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a>. A drawable is a visual component that can be connected to an image recognized target (<a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>) or a geolocated object (<a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a>). The <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> is initialized by the image and its size. Optional parameters allow to position it relative to the recognized target.</p>
<p>After we laid the groundwork in the previous function let&#39;s move on to the first call in the <code>init</code> function, the <code>createTracker</code> function.</p>
<pre><code class="lang-js">createTracker: function createTrackerFn() {
    World.tracker = new AR.CloudTracker(&quot;b277eeadc6183ab57a83b07682b3ceba&quot;, &quot;54e4b9fe6134bb74351b2aa3&quot;, {
        onLoaded: this.worldLoaded,
        onError: this.trackerError
    });
},
</code></pre>
<p>As you can see in the code above we pass three parameters to the <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>. The first parameter represents the Client API authentication token, in the example above we will use the public Wikitude authentication token. Read more about <a href="gettingstartedcloudrecognition.html#authentication">authentication and tokens</a> here. The second parameter represents the target collection id. This unique id will identify which cloud archive the <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a> will use from all the cloud archives connected to your authentication token. Optional parameters are passed as object in the last argument. In this case a callback function for the <code>onLoaded</code> and <code>onError</code> trigger are set. </p>
<p>Once the server fully loaded the <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a> the <code>worldLoaded()</code> function is called. If there was a problem initializing the <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a> the SDK will call the function <code>trackerError()</code>. Note the initialization can take a few seconds, especially when working with large cloud archives.</p>
<p>After the SDK calls the <code>worldLoaded()</code> function we continue with our wine sample and want to display a &#39;Scan&#39;-Button to the user. Clicking this button  starts the image recognition process by sending the current camera frame to the cloud recognition server. The next code fragment contains the <code>onClick</code> listener function for this button.</p>
<pre><code class="lang-js">scan: function scanFn() {
    World.tracker.recognize(this.onRecognition, this.onRecognitionError); 
},
</code></pre>
<p>After the user clicked the &quot;Scan&quot; button the Wikitude SDK calls the recognize function on the previously created <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>. The tracker recognize function is passed two callback functions. The first callback will be called by the SDK after each recognition cycle. The second will be called if there is something wrong with the specified cloud archive. </p>
<p>The next code snipped contains the first callback function <code>onRecognition</code>.</p>
<pre><code class="lang-js">onRecognition: function onRecognitionFn(recognized, response) {
    if (recognized) {
        if (World.wineLabel !== undefined) {
            World.wineLabel.destroy();
        }

        if (World.wineLabelOverlay !== undefined) {
            World.wineLabelOverlay.destroy();
        }

        World.wineLabel = new AR.ImageResource(&quot;assets/&quot; + response.targetInfo.name + &quot;.jpg&quot;);
        World.wineLabelOverlay = new AR.ImageDrawable(World.wineLabel, 0.3, {
            offsetX: -0.5,
            offsetY: -0.6,
            zOrder: 1                
        });

        if (World.wineLabelAugmentation !== undefined) {
            World.wineLabelAugmentation.destroy();
        }

        World.wineLabelAugmentation = new AR.Trackable2DObject(World.tracker, response.targetInfo.name , {
            drawables: {
                cam: [World.bannerImgOverlay, World.wineLabelOverlay]
            }
        });
    } else {
        document.getElementById(&#39;errorMessage&#39;).innerHTML = &quot;&lt;div class=&#39;errorMessage&#39;&gt;Recognition failed, please try again!&lt;/div&gt;&quot;;

        setTimeout(function() {
            var e = document.getElementById(&#39;errorMessage&#39;);
            e.removeChild(e.firstChild);
        }, 3000);
    }        
},
</code></pre>
<p>The first parameter of this callback function is a boolean value which indicates if the server was able to recognize the target, its value will either be <code>0</code> or <code>1</code> depending on the outcome. The second parameter is a JSON object which will contain metadata about the recognized target. If a target was recognized this JSON object will contain another JSON object named <code>targetInfo</code>, which consists of the target name (<code>targetName</code>), its star rating (<code>rating</code>) and optional its physical height. If no target was recognized the JSON object will be empty. More information on the response object will follow in the next chapters.</p>
<p>If the recognition was successful we would like to display the banner augmentation. To display the label of the recognized wine on top of the previously created banner, another overlay is defined. The property <code>targetInfo.name</code> contained in the response object is read to load the equally named image file. The <code>zOrder</code> property (defaults to 0) is set to 1 to make sure it will be positioned on top of the banner.</p>
<p>After that, we combine everything by creating an <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> using the CloudTracker, the name of the image target (targetInfo.name) and the drawables that should augment the recognized image.</p>
<p>If on the other hand the recognition failed we will show an error message to the user.</p>
<p><a id="continousvsonclick"></a></p>
<h3 id="continuous-recognition-vs-on-click-2-3-">Continuous Recognition vs On-click (2/3)</h3>
<p>This chapter will build upon the first chapter. Only relevant changes will be shown, please read the previous chapter before continuing.</p>
<p>In the first sample of this section we triggered the recognition mode manually (&quot;Tap To Scan&quot;). This is useful in some situations but sometime you probably want to use the continuous mode (&quot;Continuous Search&quot;), explained in the following chapter. The main difference is that the recognition will now be triggered continuously in a defined time interval instead of once by a manual click.</p>
<p>Let&#39;s look at the changes necessary to enable this functionality.</p>
<p>The first change takes place in the &#39;trackerLoaded&#39; function. In the sample before we would only show some instructions to the user, now we&#39;ll also start the continuous recognition mode.</p>
<pre><code class="lang-js">    trackerLoaded: function trackerLoadedFn() {
        this.startContinuousRecognition(750);
        this.showUserInstructions();
    },
</code></pre>
<p>We call the function <code>startContinuousRecognition</code> with the parameter <code>750</code>. This parameter represents a time interval which we&#39;ll use to tell the SDK how often a recognition should be started. The snippet below shows the code of the function <code>startContinuousRecognition</code>.</p>
<pre><code class="lang-js">startContinuousRecognition: function startContinuousRecognitionFn(interval) {
    this.tracker.startContinuousRecognition(interval, this.onRecognition, this.onRecognitionError, this.onInterruption);
},
</code></pre>
<p>In the function above we start the continuous recognition by calling the <code>startContinuousRecognition</code> function of the <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>. It is passed four parameters, the first is the already mentioned time interval in which a new recognition is started. It is set in milliseconds and the minimum value is <code>500</code>. The second parameter defines a callback function for when a recognition cycle is completed. The third parameter defines the <code>onRecognitionError</code> callback. The fourth and last parameter defines yet another callback function which is called by the SDK if the recognition interval was set too high for the current network speed.</p>
<p>We will now take a look at the changes to the callback functions. The <code>onRecognition</code> function has a slight change, the <code>onRecognitionError</code> function stays the same and there is a new callback called <code>onInterruption</code>.</p>
<p>First the <code>onRecognition</code> function.</p>
<pre><code class="lang-js">onRecognition: function onRecognitionFn(recognized, response) {
    if (recognized) {
        if (World.wineLabel !== undefined) {
            World.wineLabel.destroy();
        }

        if (World.wineLabelOverlay !== undefined) {
            World.wineLabelOverlay.destroy();
        }

        World.wineLabel = new AR.ImageResource(&quot;assets/&quot; + response.targetInfo.name + &quot;.jpg&quot;);
        World.wineLabelOverlay = new AR.ImageDrawable(World.wineLabel, 0.27, {
            offsetX: -0.5,
            offsetY: -0.6,
            zOrder: 1
        });

        if (World.wineLabelAugmentation !== undefined) {
            World.wineLabelAugmentation.destroy();
        }

        World.wineLabelAugmentation = new AR.Trackable2DObject(World.tracker, response.targetInfo.name , {
            drawables: {
                cam: [World.bannerImgOverlay, World.wineLabelOverlay]
            }
        });
    }
},
</code></pre>
<p>The only change is that we removed the error message when there was no recognition since this will happen fairly often when the user does not point the camera on the actual target.</p>
<p>The next function <code>onInterruption</code> wasn&#39;t necessary in the last example. Take a look at it in the next snippet.</p>
<pre><code class="lang-js">onInterruption: function onInterruptionFn(suggestedInterval) {
    World.tracker.stopContinuousRecognition();
    World.tracker.startContinuousRecognition(suggestedInterval);
},
</code></pre>
<p>In case the current network speed isn&#39;t fast enough for the set interval, the Wikitude SDK calls this callback function with a new suggested interval more appropriate to the current network speed. To set the new interval the recognition mode will be restarted.</p>
<p>This example showed how to enable the continuous mode of <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>, in the next sample we will take a look at how to use the server response object and custom metadata.</p>
<p><a id="metainformation"></a></p>
<h3 id="using-metainformation-in-the-response-3-3-">Using MetaInformation in the response (3/3)</h3>
<p>As the previous chapter this chapter builds upon the chapters before. Again please read the first two chapters before you get started with this.</p>
<p>In this section we add another augmentation for the end user. Again the image overlay does not change depending on the recognized target, so we create it once in the <code>createOverlays</code> function. Let&#39;s have a look.</p>
<pre><code class="lang-js">createOverlays: function createOverlaysFn() {
    this.bannerImg = new AR.ImageResource(&quot;assets/bannerWithNameField.jpg&quot;);
    this.bannerImgOverlay = new AR.ImageDrawable(this.bannerImg, 0.4, {
        offsetX: 0,
        offsetY: 0.6,
    });

    this.orderNowButtonImg = new AR.ImageResource(&quot;assets/orderNowButton.png&quot;);
    this.orderNowButtonOverlay = new AR.ImageDrawable(this.orderNowButtonImg, 0.3, {
        offsetX: 0,
        offsetY: -0.6,
    });
},
</code></pre>
<p>The new augmentation we will display is an &quot;Order Now&quot; button. It is created in the same manner as the previous augmentations.</p>
<p>All other changes took place in the &#39;onRecognition&#39; function shown below.</p>
<pre><code class="lang-js">onRecognition: function onRecognitionFn(recognized, response) {
    if (recognized) {
        if (World.wineLabelOverlay !== undefined) {
            World.wineLabel.destroy();
        }

        if (World.wineLabelOverlay !== undefined) {
            World.wineLabelOverlay.destroy();
        }

        World.wineLabel = new AR.ImageResource(&quot;assets/&quot; + response.targetInfo.name + &quot;.jpg&quot;);
        World.wineLabelOverlay = new AR.ImageDrawable(World.wineLabel, 0.2, {
            offsetX: -0.37,
            offsetY: 0.55,
            zOrder: 1
        });

        World.wineName = new AR.Label(response.metadata.name, 0.06, {
            offsetY: 0.72,
            zOrder: 2
        });

        if (World.wineLabelAugmentation !== undefined) {
            World.wineLabelAugmentation.destroy();
        }

        World.wineLabelAugmentation = new AR.Trackable2DObject(World.tracker, response.targetInfo.name , {
            drawables: {
                cam: [World.bannerImgOverlay, World.wineLabelOverlay, World.wineName]
            }
        });

        World.orderNowButtonOverlay.onClick = function() {
            AR.context.openInBrowser(response.metadata.shop_url);
        }

        if (World.orderNowAugmentation !== undefined) {
            World.orderNowAugmentation.destroy();
        }

        World.orderNowAugmentation = new AR.Trackable2DObject(World.tracker, response.targetInfo.name, {
            drawables: {
                cam: World.orderNowButtonOverlay
            }
        });
    }
},
</code></pre>
<p>When the cloud archive was created custom metadata for every target was defined. You are a free to choose the content of the metadata depending on your needs. See the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-Target-CreateTarget">Manager API documentation</a> on how to add metadata for a target. For this example, we created two fields:</p>
<ul>
<li><code>metadata.name</code> which represents the real name of the wine and </li>
<li><code>metadata.shop_url</code> a url to a webshop stocking the particular wine were defined. </li>
</ul>
<p>The corresponding JSON when creating targets on the Manager API looks like the following:</p>
<pre><code class="lang-js">    &quot;metadata&quot;:{
         &quot;name&quot;:&quot;Lote 43 Cabernet Sauvignon-Merlot&quot;,
        &quot;shop_url&quot;:&quot;http://loja.miolo.com.br/ch/index.aspx&quot;
     }
</code></pre>
<p>To display the name of the wine in the banner overlay, an <a href="../Reference/JavaScript%20API/classes/Label.html"><code>AR.Label</code></a> is created. The first parameter defines the text of the label, the second its height in SDUs, the third parameter sets some optional options. To set the first parameter of the <a href="../Reference/JavaScript%20API/classes/Label.html"><code>AR.Label</code></a> we read the before mentioned <code>name</code> from the custom metadata object. Since the response object returned by the server is a JSON object it is possible to navigate it by dot notation.</p>
<p>Like the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> objects we created before, we add the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.Label</code></a> to the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> which combines everything for our banner.</p>
<p>Next we add a <code>onClick</code> handler to the <code>orderNowButtonOverlay</code> where we make use of the <a href="../Reference/JavaScript%20API/classes/context.html"><code>AR.context</code></a> class to open the shop&#39;s website in browser. Again we utilize the server response object and our custom metadata to read the url for the current target from <code>shop_url</code>.</p>

<h2 id="3d-models">3D Models</h2>
<p>This example shows how to augment a target image with 3D content. It starts by displaying a 3D model on a target and advances by adding displayed animations, interactivity and demonstrates the snap-to-screen functionality. The last example shows how 3D content can be placed at a certain geographic location.</p>
<p>If you are not yet familiar with how to create a vision based augmented reality scene (based on image recognition and tracking), please have a look at the previous example <a href="clientrecognition.html">Client Recognition</a>.</p>
<p>3D content within Wikitude can only be loaded from <code>Wikitude 3D Format</code> files (.wt3).  This is a compressed binary format for describing 3D content which is optimized for fast loading and handling of 3D content on a mobile device. You still can use 3D models from your favorite 3D modeling tools (Autodesk® Maya® or Blender) but you&#39;ll need to convert them into the wt3 file format. The Wikitude 3D Encoder desktop application (Windows and Mac) encodes your 3D source file. The Encoder can handle Autodesk® FBX® files (.fbx) and the open standard Collada (.dae) file formats for encoding to .wt3.</p>
<p>For more details on how to convert your 3D content please see the <a href="encoder.html">Wikitude 3D Encoder</a> section. In this example the .wt3 file has already been prepared and saved to assets/car.wt3.</p>
<p>3D content is rendered on top of 2D objects. This limitation exists because of some SDK internal restrictions and might change in an upcoming release.</p>
<p>This sample consists of four parts</p>
<ol>
<li><a href="#3dmodelontarget">3D Model on Target Image</a></li>
<li><a href="#appearinganimation">Appearing Animation</a></li>
<li><a href="#interactivity">Interactivity</a></li>
<li><a href="#snapToScreen">Snap to Screen</a></li>
<li><a href="#model_parts_animation">Animation of Model Parts</a></li>
<li><a href="#3dModelAtGeoLocation">3D Model at GeoLocation</a></li>
</ol>
<p><img src="images/car.jpg" alt="Rendering of car model in Wikitude 3D Encoder" title="Rendering of the car model used in this example."></p>
<p>The following fictional print advertisement is used as target image, which will be augmented with a 3D model of the car advertised in the print ad.</p>
<p><img src="images/carAd.jpg" alt="Print ad used as image target" title="Car ad used as image target."></p>
<p><a id="3dmodelontarget"></a></p>
<h3 id="3d-model-on-target-1-6-">3D Model on Target (1/6)</h3>
<p>First of all create an <a href="../Reference/JavaScript%20API/classes/Model.html"><code>AR.Model</code></a> and pass the URL to the actual .wt3 file of the model. Additional options allow for scaling, rotating and positioning the model in the scene.</p>
<pre><code class="lang-js">this.modelCar = new AR.Model(&quot;assets/car.wt3&quot;, {
    onLoaded: this.loadingStep,
    scale: {
        x: 0.045,
        y: 0.045,
        z: 0.045
    },
    translate: {
        x: 0.0,
        y: 0.05,
        z: 0.0
    },
    rotate: {
        roll: -25
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_1_3dModelOnTarget/js/3dmodelontarget.js#L31-L46">GitHub</a>
</div>

<p>In this example a function is attached to the <code>onLoaded</code> trigger to receive a notification once the 3D model is fully loaded. Depending on the size of the model and where it is stored (locally or remotely) it might take some time to completely load and it is recommended to inform the user about the loading time.</p>
<p>Similar to 2D content the 3D model is added to the <code>drawables.cam</code> property of an <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>. </p>
<pre><code class="lang-js">var trackable = new AR.Trackable2DObject(this.tracker, &quot;*&quot;, {
    drawables: {
        cam: [this.modelCar]
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_1_3dModelOnTarget/js/3dmodelontarget.js#L51-L55">GitHub</a>
</div>

<p>This is everything that is needed to allow the 3D model appear on an image target. To adjust scaling and position of the model pass the scale and translate properties as options to the <a href="../Reference/JavaScript%20API/classes/Model.html"><code>AR.Model</code></a>.</p>
<p>To view the sample you can use the image in <a href="targetimages.html">on this page</a></p>
<p><a id="appearinganimation"></a></p>
<h3 id="appearing-animation-2-6-">Appearing Animation (2/6)</h3>
<p>As a next step, an appearing animation is added which scales up the 3D model once the target is inside the field of vision. Creating an animation on a single property of an object is done using an <a href="../Reference/JavaScript%20API/classes/PropertyAnimation.html"><code>AR.PropertyAnimation</code></a>. Since the car model needs to be scaled up on all three axis, three animations are needed. These animations are grouped together utilizing an <a href="../Reference/JavaScript%20API/classes/AnimationGroup.html"><code>AR.AnimationGroup</code></a> that allows them to play them in parallel.</p>
<pre><code class="lang-js">var sx = new AR.PropertyAnimation(model, &quot;scale.x&quot;, 0, scale, 1500, {
    type: AR.CONST.EASING_CURVE_TYPE.EASE_OUT_QUAD
});
var sy = new AR.PropertyAnimation(model, &quot;scale.y&quot;, 0, scale, 1500, {
    type: AR.CONST.EASING_CURVE_TYPE.EASE_OUT_QUAD
});
var sz = new AR.PropertyAnimation(model, &quot;scale.z&quot;, 0, scale, 1500, {
    type: AR.CONST.EASING_CURVE_TYPE.EASE_OUT_QUAD
});

return new AR.AnimationGroup(AR.CONST.ANIMATION_GROUP_TYPE.PARALLEL, [sx, sy, sz]);
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_2_AppearingAnimation/js/appearinganimation.js#L87-L97">GitHub</a>
</div>

<p>Each <a href="../Reference/JavaScript%20API/classes/PropertyAnimation.html"><code>AR.PropertyAnimation</code></a> targets one of the three axis and scales the model from 0 to the value passed in the <code>scale</code> variable. An <code>EASE_OUT_QUAD</code> easing curve is used to create a more dynamic effect of the animation.</p>
<p>To get a notification once the image target is inside the field of vision the <code>onEnterFieldOfVision</code> trigger of the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> is used. In the example the function <code>appear()</code> is attached.</p>
<pre><code class="lang-js">appear: function appearFn () {
    World.appearingAnimation.start();
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_2_AppearingAnimation/js/appearinganimation.js#L100-L102">GitHub</a>
</div>

<p>Within the <code>appear</code> function the previously created <a href="../Reference/JavaScript%20API/classes/AnimationGroup.html"><code>AR.AnimationGroup</code></a> is started by calling its <code>start()</code> function which plays the animation once.</p>
<p><a id="interactivity"></a></p>
<h3 id="interactivity-3-6-">Interactivity (3/6)</h3>
<p>To add more functionality, a rotating animation is added to the 3D model. It is started and paused by clicking on the button or on the 3D model.</p>
<p>Additionally to the 3D model an image that will act as a button is added to the image target. This can be accomplished by loading an <a href="../Reference/JavaScript%20API/classes/ImageResource.html"><code>AR.ImageResource</code></a> and creating a drawable from it.</p>
<pre><code class="lang-js">var imgRotate = new AR.ImageResource(&quot;assets/rotateButton.png&quot;);
var buttonRotate = new AR.ImageDrawable(imgRotate, 0.2, {
    offsetX: 0.35,
    offsetY: 0.45,
    onClick: this.toggleAnimateModel
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_3_Interactivity/js/interactivity.js#L67-L72">GitHub</a>
</div>

<p>To add the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> to the image target together with the 3D model both drawables are supplied to the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>.</p>
<pre><code class="lang-js">var trackable = new AR.Trackable2DObject(this.tracker, &quot;*&quot;, {
    drawables: {
        cam: [this.modelCar, buttonRotate]
    },
    onEnterFieldOfVision: this.appear
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_3_Interactivity/js/interactivity.js#L79-L84">GitHub</a>
</div>

<p>The rotation animation for the 3D model is created by defining an <a href="../Reference/JavaScript%20API/classes/PropertyAnimation.html"><code>AR.PropertyAnimation</code></a> for the <code>rotate.roll</code> property.</p>
<pre><code class="lang-js">// Rotation Animation
this.rotationAnimation = new AR.PropertyAnimation(this.modelCar, &quot;rotate.roll&quot;, -25, 335, 10000);
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_3_Interactivity/js/interactivity.js#L62">GitHub</a>
</div>

<p>The drawables are made clickable by setting their <code>onClick</code> triggers. Click triggers can be set in the options of the drawable when the drawable is created. Thus, when the 3D model <code>onClick: this.toggleAnimateModel</code> is set in the options it is then passed to the <a href="../Reference/JavaScript%20API/classes/Model.html"><code>AR.Model</code></a> constructor. Similar the button&#39;s <code>onClick: this.toggleAnimateModel</code> trigger is set in the options passed to the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> constructor. <code>toggleAnimateModel()</code> is therefore called when the 3D model or the button is clicked.</p>
<p>Inside the <code>toggleAnimateModel()</code> function, it is checked if the animation is running and decided if it should be started, resumed or paused.</p>
<pre><code class="lang-js">toggleAnimateModel: function toggleAnimateModelFn() {
    if (!World.rotationAnimation.isRunning()) {
        if (!World.rotating) {
            World.rotationAnimation.start(-1);
            World.rotating = true;
        } else {
            World.rotationAnimation.resume();
        }
    } else {
        World.rotationAnimation.pause();
    }

    return false;
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_3_Interactivity/js/interactivity.js#L135-L151">GitHub</a>
</div>

<p>Starting an animation with <code>.start(-1)</code> will loop it indefinitely.</p>
<p><a id="snapToScreen"></a></p>
<h3 id="snap-to-screen-4-6-">Snap to Screen (4/6)</h3>
<p>To finish things up, the snap to screen feature is added so that the 3D model can be explored in a more immersive way. Snap to screen will bring the drawables, attached to a <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>, out of the augmented reality scene and directly onto the screen. Once snapped, the drawables will stay on the screen as long as they are not set back into the augmented reality context. Thereby users can explore content even if they don&#39;t look at the target image.</p>
<p>The snap position on the screen is defined through a <code>div</code> element. During the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> creation, the <code>div</code> is passed as a additional option. In this example a <code>div</code> with id <code>snapContainer</code> is used.</p>
<pre><code class="lang-js">this.trackable = new AR.Trackable2DObject(this.tracker, &quot;*&quot;, {
    drawables: {
        ...
    },
    snapToScreen: {
        snapContainer: document.getElementById(&#39;snapContainer&#39;)
    },
    ...
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_4_SnapToScreen/js/snaptoscreen.js#L139-L147">GitHub</a>
</div>

<p>Snapping is then enabled through an additional button. The button is created and setup just the same way as the rotate button. The only difference is that the <code>onClick</code> function of the newly created button is pointing to a different function.</p>
<pre><code class="lang-js">toggleSnapping: function toggleSnappingFn() {

    World.snapped = !World.snapped;        
    World.trackable.snapToScreen.enabled = World.snapped;

    if ( !World.snapped ) {

        World.applyLayout(World.layout.snapped);

        World.addInteractionEventListener();

    } else {

        World.applyLayout(World.layout.normal);

        World.removeInteractionEventListener();
    }
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_4_SnapToScreen/js/snaptoscreen.js#L295-L312">GitHub</a>
</div>

<p>To enable snapping, set the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> property <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html#property_snapToScreen.enabled"><code>snapToScreen.enabled</code></a> accordingly (either <code>true</code> or <code>false</code>). Based on the current snapping state, the drawables are positioned and scaled differently and event listeners are added or removed so that the 3D model can only be modified while it is snapped.</p>
<p>In the sample the 3D model can be rotated and scaled through touch and gesture events once it is snapped to the screen. To apply the new rotation and scale values, the JavaScript events <code>touchmoved</code> and <code>gesturechange</code> are used. Inside these listener functions scale and rotation values are calculated and applied to the 3D model.</p>
<p><a id="model_parts_animation"></a></p>
<h3 id="animation-of-model-parts-5-6-">Animation of Model Parts (5/6)</h3>
<p>A 3D model represents a set of triangle meshes which can further be subdivided in mesh parts. Each mesh or mesh part stores material properties and transformations which determines its appearance and spatial position. 
In case of the red Lamborghini model discussed above the wheels, doors, roof and the hood, a.s.o. represent meshes. The car&#39;s door, for example, is further subdivided into mesh parts representing the door&#39;s frame, side mirror or door handle. The grouping of meshes parts allows to animate parts of the 3D model independently. In the Lamborghini example the door with all its parts can be opened (see figure below).</p>
<p><img src="images/car_animated_door.png" alt="Animation of a model part in the 3D Encoder" title="Animation of a model part in the 3D Encoder."></p>
<p>Meshes and mesh parts and can have identifiers which are passed to the <a href="../Reference/JavaScript%20API/classes/Model.html#event_onClick"><code>onClick</code></a> trigger function of the <a href="../Reference/JavaScript%20API/classes/Model.html#event_onClick"><code>AR.Model</code></a> as parameter <code>modelPart</code>. This allows to apply different actions when certain parts of a 3D model have been clicked/touched by the user. In the code snippet shown below the parameter <code>modelPart</code> is used in a switch instruction. If the <code>modelPart</code> reported is part of the car&#39;s left door an animation from the 3D model is created and started. Otherwise the identifier of the mesh or mesh part (parameter <code>modelPart</code>) is displayed in a pop-up window via the alert function.</p>
<pre><code class="lang-js">var model = new AR.Model(&quot;assets/car_animated.wt3&quot;, {
    ...
    onClick : function( drawable, modelPart ) 
    {
        switch(modelPart) 
        {
            case &#39;WindFL&#39;: 
            case &#39;DoorL[0]&#39;:
            case &#39;DoorL[1]&#39;:
            case &#39;DoorL[2]&#39;:
            case &#39;DoorL[3]&#39;:
                var anim = new AR.ModelAnimation( model, &quot;DoorOpenL_animation&quot; );
                anim.start();
                break;

            default:
                alert( &#39;clicked: &#39; + model_part );
        }
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_5_AnimatedModelParts/js/3dmodels.js#L47-L81">GitHub</a>
</div>

<p>The identifiers of the mesh parts are provided by the 3D model. They are specified by the modeling tool the 3D model was created with (e.g. 3d Studio Max, Maya, Blender, ...). A list of meshes and mesh parts for a 3D model can be obtained from by the <a href="encoder.html">Wikitude 3D Encoder</a> (see figure below). If a mesh consists of single part, the identifier contains the name of the mesh, e.g., &#39;WindFL&#39;. If it consists of several parts, the identifier contains the index of the part in square brackets attached to its name, e.g., <code>DoorL[0]</code>. </p>
<p><img src="images/car_animated_3dencoder.png" alt="Copy identifiers of model parts with the 3D Encoder" title="Copy identifiers of model parts with the 3D Encoder."></p>
<p><a id="3dModelAtGeoLocation"></a></p>
<h3 id="3d-model-at-geolocation-6-6-">3D Model at GeoLocation (6/6)</h3>
<p>Beside rendering 3D models on top of recognized target images, the Wikitude SDK can also render 3D models at any kind of location. In the example below we are showing how to place a 3D model at a specific relative location. The location of the 3D model is relative to the user&#39;s current position and placed about 5 meters away to the north and 2 meters above. We are using a relative location so it is easier for you to try it out on your own, however it is easy to change that to a real geo-location. (See <a href="../Reference/JavaScript%20API/classes/GeoLocation.html"><code>AR.GeoLocation</code></a> and <a href="../Reference/JavaScript%20API/classes/RelativeLocation.html"><code>AR.RelativeLocation</code></a> for details)</p>
<pre><code class="lang-js">/*
    First a location where the model should be displayed will be defined. This location will be relative to the user.    
*/
var location = new AR.RelativeLocation(null, 5, 0, 2);

/*
    Next the model object is loaded.
*/
var modelEarth = new AR.Model(&quot;assets/earth.wt3&quot;, {
    onLoaded: this.worldLoaded,
    scale: {
        x: 1,
        y: 1,
        z: 1
    }
});

/*
    Putting it all together the location and 3D model is added to an AR.GeoObject.
*/
var obj = new AR.GeoObject(location, {
    drawables: {
       cam: [modelEarth]
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/3_3dModels_6_3dModelAtGeoLocation/js/3dmodelatgeolocation.js#L14-L42">GitHub</a>
</div>

<p>When starting the experience you will need to point your camera a little bit to the east and little bit up and you will see a 3D model of the earth floating in front of you. </p>

<h2 id="point-of-interest-poi-">Point Of Interest (POI)</h2>
<p>The Point Of Interest (POI) example series will show how you can create a marker that is placed at a specific geolocation. The example is split into four different parts that depend on each other. You will have a complete and reusable marker at the end of the series which has a title, description, a selected and an idle state which animates smoothly from one to another.</p>
<p>This sample consists of four parts</p>
<ol>
<li><a href="#poiatlocation">POI at Location</a></li>
<li><a href="#poiwithlabel">POI with Label</a></li>
<li><a href="#multiplepois">Multiple POIs</a></li>
<li><a href="#selectingpois">Selecting POIs</a></li>
</ol>
<p><a id="poiatlocation"></a></p>
<h3 id="poi-at-location-1-4-">POI at Location (1/4)</h3>
<p>The first part of the series will present an image at a geolocation. To do so, we will use the <code>AR.context.onLocationChanged()</code> callback to get the current location. After the location has been retrieved, we will use it to place an <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> there.</p>
<p>All JavaScript code can be found in the file <code>poiatlocation.js</code>.</p>
<p>The example <a href="clientrecognition.html">Client Recognition</a> already explained how images are loaded and displayed in the augmented reality view. This sample loads an <a href="../Reference/JavaScript%20API/classes/ImageResource.html"><code>AR.ImageResource</code></a> when the <code>World</code> variable was defined. It will be reused for each marker that we will create afterwards.</p>
<p>The last line of the <code>poiatlocation.js</code> shows how to set a custom <code>AR.context.onLocationChanged</code> callback.</p>
<pre><code class="lang-js">AR.context.onLocationChanged = World.onLocationChanged;
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_1_PoiAtLocation/js/poiatlocation.js#L76">GitHub</a>
</div>

<p>The custom function <code>World.onLocationChanged</code> checks with the flag <code>World.initiallyLoadedData</code> if  the function was already called. There is also a possibility to set <code>AR.context.onLocationChanged</code> to null. In this case the function will not be called anymore and no further location updates will be received.</p>
<p>On the first call of <code>World.onLocationChanged</code> an object that contains geo information will be created which will be later used to create a marker using the <code>World.loadPoisFromJsonData</code> function.</p>
<pre><code class="lang-js">locationChanged: function locationChangedFn(lat, lon, alt, acc) {
    // request data if not already present
    if (!World.initiallyLoadedData) {
        var poiData = {
            &quot;id&quot;: 1,
            &quot;longitude&quot;: (lon + (Math.random() / 5 - 0.1)),
            &quot;latitude&quot;: (lat + (Math.random() / 5 - 0.1)),
            &quot;altitude&quot;: 100.0
        };
        World.loadPoisFromJsonData(poiData);
        World.initiallyLoadedData = true;
    }
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_1_PoiAtLocation/js/poiatlocation.js#L58-L69">GitHub</a>
</div>

<p>The <code>loadPoisFromJsonData</code> function creates an <a href="../Reference/JavaScript%20API/classes/ImageResource.html"><code>AR.ImageResource</code></a> which is later used as an image for the marker.</p>
<pre><code class="lang-js">// start loading marker assets
World.markerDrawable_idle = new AR.ImageResource(&quot;assets/marker_idle.png&quot;);
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_1_PoiAtLocation/js/poiatlocation.js#L15">GitHub</a>
</div>

<p>For creating the marker a new object <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> will be created at the specified geolocation. An <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> connects one or more <code>AR.GeoLocations</code> with multiple <code>AR.Drawables</code>. The <code>AR.Drawables</code> can be defined for multiple targets. A target can be the camera, the radar or a direction indicator. Both the radar and direction indicators will be covered in more detail in later examples.</p>
<pre><code class="lang-js">    // create the marker
    var markerLocation = new AR.GeoLocation(poiData.latitude, poiData.longitude, poiData.altitude);
    var markerImageDrawable_idle = new AR.ImageDrawable(markerDrawable_idle, 2.5, {
        zOrder: 0,
        opacity: 1.0
    });
I
    // create GeoObject
    var markerObject = new AR.GeoObject(markerLocation, {
        drawables: {
            cam: [markerImageDrawable_idle]
        }
    });
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_1_PoiAtLocation/js/poiatlocation.js#L20-L31">GitHub</a>
</div>

<p>Finally the status message is updated as a user feedback that everything was loaded properly:</p>
<pre><code class="lang-js">World.updateStatusMessage(&#39;1 place loaded&#39;);
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_1_PoiAtLocation/js/poiatlocation.js#L34">GitHub</a>
</div>

<p><a id="poiwithlabel"></a></p>
<h3 id="poi-with-label-2-4-">POI with Label (2/4)</h3>
<p>The second part adds a title and description label to our marker object and covers more drawable related options.</p>
<p><img src="images/sample_poi_poiwithlabel.jpg" alt=""></p>
<p>All JavaScript changes are in <code>poiwithlabel.js</code>. Note that the file is only renamed but its content is mostly identical to <code>poiatlocation.js</code>.</p>
<p>The <code>locationChanged</code> function adds a description and a title to the marker:</p>
<pre><code class="lang-js">var poiData = {
    &quot;id&quot;: 1,
    &quot;longitude&quot;: (lon + (Math.random() / 5 - 0.1)),
    &quot;latitude&quot;: (lat + (Math.random() / 5 - 0.1)),
    &quot;altitude&quot;: 100.0,
    &quot;description&quot;: &quot;This is the description of POI#1&quot;,
    &quot;title&quot;: &quot;POI#1&quot;
};
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_2_PoiWithLabel/js/poiwithlabel.js#L49-L56">GitHub</a>
</div>

<p>Since there are additional changes concerning the marker it makes sense to extract the code to a separate <code>Marker</code> class (see <strong>marker.js</strong>). Parts of the code are moved from <code>loadPoisFromJsonData</code> to the <code>Marker</code>class: the creation of the <code>AR.GeoLocation</code>, the creation of the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> and the creation of the <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a>. Then instantiate the <code>Marker</code> in the function <code>loadPoisFromJsonData</code> like this:</p>
<pre><code class="lang-js">    // create the marker
    var marker = new Marker(poiData);
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_2_PoiWithLabel/js/poiwithlabel.js#L20">GitHub</a>
</div>

<p>There are two major points that need to be considered while drawing multiple <code>AR.Drawables</code> at the same location. It has to be defined which one is before or behind another drawable (rendering order) and if they need a location offset. For both scenarios, ARchitect has some functionality to adjust the drawable behavior.</p>
<p>To position the <code>AR.Label</code> in front of the background, the background drawable(<code>AR.ImageDrawable2D</code>) receives a <code>zOrder</code> of 0. Both labels have a <code>zOrder</code> of 1. This way it is guaranteed that the labels will be drawn in front of the background drawable.</p>
<p>Assuming both labels will be drawn on the same geolocation connected with the same <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> they will overlap. To adjust their position change the <code>offsetX</code> and <code>offsetY</code> property of an <code>AR.Drawable2D</code> object. The unit for offsets are SDUs. See this chapter for more information about <a href="sdu-dbs.html">SDUs</a>.</p>
<p>In the following both <code>AR.Labels</code> are initialized and positioned. Note that they are added to the cam property of the <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> the same way as an <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a>.</p>
<pre><code class="lang-js">function Marker(poiData) {

    this.poiData = poiData;

    var markerLocation = new AR.GeoLocation(poiData.latitude, poiData.longitude, poiData.altitude);
    this.markerDrawable_idle = new AR.ImageDrawable(World.markerDrawable_idle, 2.5, {
        zOrder: 0,
        opacity: 1.0
    });

    this.titleLabel = new AR.Label(poiData.title.trunc(10), 1, {
        zOrder: 1,
        offsetY: 0.55,
        style: {
            textColor: &#39;#FFFFFF&#39;,
            fontStyle: AR.CONST.FONT_STYLE.BOLD
        }
    });

    this.descriptionLabel = new AR.Label(poiData.description.trunc(15), 0.8, {
        zOrder: 1,
        offsetY: -0.55,
        style: {
            textColor: &#39;#FFFFFF&#39;
        }
    });

    // Changed: 
    this.markerObject = new AR.GeoObject(markerLocation, {
        drawables: {
            cam: [this.markerDrawable_idle, this.titleLabel, this.descriptionLabel]
        }
    });

    return this;
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_2_PoiWithLabel/js/marker.js#L1-L49">GitHub</a>
</div>

<p>Additionally a function which truncates a text string that is longer than the given length is added. This function is used to shorten titles or descriptions.</p>
<pre><code class="lang-js">String.prototype.trunc = function(n) {
       return this.substr(0, n - 1) + (this.length &gt; n ? &#39;...&#39; : &#39;&#39;);
};
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_2_PoiWithLabel/js/marker.js#L53-L55">GitHub</a>
</div>

<p><a id="multiplepois"></a></p>
<h3 id="multiple-pois-3-4-">Multiple POIs (3/4)</h3>
<p>The third example consist of two parts. The first part shows how to create multiple markers and in the second part an implementation of a marker selection is described. </p>
<p><img src="images/sample_poi_multiple_poi.jpg" alt=""></p>
<p>For creating multiple markers change the class <code>World</code>. Add a function <code>requestDataFromLocal</code> with the geo information as parameters (latitude, longitude) which are used for creating different poi data to a random location in the user&#39;s vicinity. The new function is called from <code>locationChanged</code> instead of calling <code>loadPoisFromJsonData</code> like in the previous example:</p>
<pre><code class="lang-js">World.requestDataFromLocal(lat, lon);
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_3_MultiplePois/js/multiplepois.js#L71">GitHub</a>
</div>

<p>The function <code>loadPoisFromJsonData</code> will be called within the new function <code>requestDataFromLocal</code> after the POI data was created:</p>
<pre><code class="lang-js">
    // request POI data
    requestDataFromLocal: function requestDataFromLocalFn(centerPointLatitude, centerPointLongitude) {
        var poisToCreate = 20;
        var poiData = [];

        for (var i = 0; i &lt; poisToCreate; i++) {
            poiData.push({
                &quot;id&quot;: (i + 1),
                &quot;longitude&quot;: (centerPointLongitude + (Math.random() / 5 - 0.1)),
                &quot;latitude&quot;: (centerPointLatitude + (Math.random() / 5 - 0.1)),
                &quot;description&quot;: (&quot;This is the description of POI#&quot; + (i + 1)),
                &quot;altitude&quot;: &quot;100.0&quot;,
                &quot;name&quot;: (&quot;POI#&quot; + (i + 1))
            });
        }
        World.loadPoisFromJsonData(poiData);
    }
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_3_MultiplePois/js/multiplepois.js#L100-L114">GitHub</a>
</div>

<p>Since the argument of <code>loadPoisFromJsonData</code> is used as an array and not like a single object as before some adaptations are necessary. The POI information array which is delivered as an argument in the function <code>loadPoisFromJsonData</code> is used to create poiData objects. In a for loop iterate through all the poi information objects. For each object create a new object <code>singlePoi</code>. To create multiple markers <code>new Marker(poiData)</code> can be called multiple times with different locations, titles and descriptions as defined in the poiData object. Now create the <code>Marker</code> objects and store them in an array <code>markerList</code> which is defined as a member variable in the <code>World</code> class. The <code>markerList</code> array is needed for selection/deselection of markers and will be described later in this example. Finally the status message is updated with the number of POIs loaded.</p>
<pre><code class="lang-js">
        // called to inject new POI data
        loadPoisFromJsonData: function loadPoisFromJsonDataFn(poiData) {

            // empty list of visible markers
            World.markerList = [];

            // start loading marker assets
            World.markerDrawable_idle = new AR.ImageResource(&quot;assets/marker_idle.png&quot;);

            // loop through POI-information and create an AR.GeoObject (=Marker) per POI
            for (var currentPlaceNr = 0; currentPlaceNr &lt; poiData.length; currentPlaceNr++) {
                var singlePoi = {
                    &quot;id&quot;: poiData[currentPlaceNr].id,
                    &quot;latitude&quot;: parseFloat(poiData[currentPlaceNr].latitude),
                    &quot;longitude&quot;: parseFloat(poiData[currentPlaceNr].longitude),
                    &quot;altitude&quot;: parseFloat(poiData[currentPlaceNr].altitude),
                    &quot;title&quot;: poiData[currentPlaceNr].name,
                    &quot;description&quot;: poiData[currentPlaceNr].description
                };

                World.markerList.push(new Marker(singlePoi));
            }

            World.updateStatusMessage(currentPlaceNr + &#39; places loaded&#39;);
        }
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_3_MultiplePois/js/multiplepois.js#L17-L43">GitHub</a>
</div>

<p>At this point the implementation for displaying multiple markers is finished. Let&#39;s have a look on how to change the marker background image after it was selected and handle the different selection states.</p>
<p>A second <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> is defined in <code>marker.js</code>.</p>
<p>To react on user interaction, an <code>onClick</code> property can be set for each <code>AR.Drawable</code>. The property is a function which will be called each time the user taps on the drawable. The following snippet shows the adapted <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> creation.</p>
<pre><code class="lang-js">this.markerDrawable_idle = new AR.ImageDrawable(World.markerDrawable_idle, 2.5, {
    zOrder: 0,
    opacity: 1.0,
    onClick: Marker.prototype.getOnClickTrigger(this)
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_3_MultiplePois/js/marker.js#L13-L20">GitHub</a>
</div>

<p>The function called on each tap is returned from the following helper function defined in <code>marker.js</code>. The function returns a function which checks the selected state with the help of the variable <code>isSelected</code> and executes the appropriate function. The clicked marker is passed as an argument.</p>
<pre><code class="lang-js">Marker.prototype.getOnClickTrigger = function(marker) {

    return function() {
            if (marker.isSelected) {
                Marker.prototype.setDeselected(marker);

            } else {
                Marker.prototype.setSelected(marker);
                try {
                    World.onMarkerSelected(marker);
                } catch (err) {
                    alert(err);
                }
            }
    };
};
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_3_MultiplePois/js/marker.js#L58-L84">GitHub</a>
</div>

<p>The <code>setSelected</code> and <code>setDeselected</code> functions are prototype <code>Marker</code> functions.</p>
<p>Both functions perform the same steps but inverted, hence only one function (<code>setSelected</code>) is covered in detail. Three steps are necessary to select the marker. First the state will be set appropriately. Second the background drawable will be enabled and the standard background disabled. This is done by setting the opacity property to 1.0 for the visible state and to 0.0 for an invisible state. Third the <code>onClick</code> function is set only for the background drawable of the selected marker.</p>
<pre><code class="lang-js">Marker.prototype.setSelected = function(marker) {

    marker.isSelected = true;

    marker.markerDrawable_idle.opacity = 0.0;
    marker.markerDrawable_selected.opacity = 1.0;

    marker.markerDrawable_idle.onClick = null;
    marker.markerDrawable_selected.onClick = Marker.prototype.getOnClickTrigger(marker);
};
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_3_MultiplePois/js/marker.js#L86-L94">GitHub</a>
</div>

<p>To be able to deselect a marker while the user taps on the empty screen, the <code>World</code> object holds an array that contains each marker.</p>
<pre><code class="lang-js">World.markerList.push( new Marker(poiData) );
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_3_MultiplePois/js/multiplepois.js#L40">GitHub</a>
</div>

<p>To detect clicks where no drawable was hit set a custom function on <code>AR.context.onScreenClick</code> where the currently selected marker is deselected.</p>
<pre><code class="lang-js">onScreenClick: function onScreenClickFn() {
    if (World.currentMarker) {
        World.currentMarker.setDeselected(World.currentMarker);
    }
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_3_MultiplePois/js/multiplepois.js#L93-L97">GitHub</a>
</div>

<p><a id="selectingpois"></a></p>
<h3 id="selecting-pois-4-4-">Selecting POIs (4/4)</h3>
<p><img src="images/sample_poi_selecting_poi.jpg" alt=""></p>
<p>The last part describes the concepts behind <code>AR.PropertyAnimations</code> and <code>AR.AnimationGroups</code>. It also explains how direction indicators can be used to visualize selected objects that are currently not visible in the viewfinder.</p>
<p>With <code>AR.PropertyAnimations</code> you are able to animate almost any property of ARchitect objects. This sample will animate the opacity of both background drawables so that one will fade out while the other one fades in. The scaling is animated too. The marker size changes over time so the labels need to be animated too in order to keep them relative to the background drawable. <code>AR.AnimationGroups</code> are used to synchronize all animations in parallel or sequentially.</p>
<p>In <code>marker.js</code> there are two new variables declared. They hold a reference to an <a href="../Reference/JavaScript%20API/classes/AnimationGroup.html"><code>AR.AnimationGroup</code></a> that is used to either start or stop the animations.</p>
<pre><code class="lang-js">this.animationGroup_idle = null;
this.animationGroup_selected = null;
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_4_SelectingPois/js/marker.js#L13-L14">GitHub</a>
</div>

<p>The functions <code>setSelected</code> and <code>setDeselected</code> in <code>marker.js</code> have to be adapted. Again only the changes in <code>setSelected</code> are explained. </p>
<p>There are two types of <code>AR.AnimationGroups</code>. Parallel animations are running at the same time, sequential animations are played one after another. This example uses a parallel <a href="../Reference/JavaScript%20API/classes/AnimationGroup.html"><code>AR.AnimationGroup</code></a>.</p>
<pre><code class="lang-js">if (marker.animationGroup_selected === null) {

    var hideIdleDrawableAnimation = new AR.PropertyAnimation(marker.markerDrawable_idle, &quot;opacity&quot;, null, 0.0, kMarker_AnimationDuration_ChangeDrawable);
        var showSelectedDrawableAnimation = new AR.PropertyAnimation(marker.markerDrawable_selected, &quot;opacity&quot;, null, 0.8, kMarker_AnimationDuration_ChangeDrawable);

        var idleDrawableResizeAnimation = new AR.PropertyAnimation(marker.markerDrawable_idle, &#39;scaling&#39;, null, 1.2, kMarker_AnimationDuration_Resize, new AR.EasingCurve(AR.CONST.EASING_CURVE_TYPE.EASE_OUT_ELASTIC, {
            amplitude: 2.0
        }));
        var selectedDrawableResizeAnimation = new AR.PropertyAnimation(marker.markerDrawable_selected, &#39;scaling&#39;, null, 1.2, kMarker_AnimationDuration_Resize, new AR.EasingCurve(AR.CONST.EASING_CURVE_TYPE.EASE_OUT_ELASTIC, {
            amplitude: 2.0
        }));

        var titleLabelResizeAnimation = new AR.PropertyAnimation(marker.titleLabel, &#39;scaling&#39;, null, 1.2, kMarker_AnimationDuration_Resize, new AR.EasingCurve(AR.CONST.EASING_CURVE_TYPE.EASE_OUT_ELASTIC, {
            amplitude: 2.0
        }));
        var descriptionLabelResizeAnimation = new AR.PropertyAnimation(marker.descriptionLabel, &#39;scaling&#39;, null, 1.2, kMarker_AnimationDuration_Resize, new AR.EasingCurve(AR.CONST.EASING_CURVE_TYPE.EASE_OUT_ELASTIC, {
            amplitude: 2.0
        }));

        marker.animationGroup_selected = new AR.AnimationGroup(AR.CONST.ANIMATION_GROUP_TYPE.PARALLEL, [hideIdleDrawableAnimation, showSelectedDrawableAnimation, idleDrawableResizeAnimation, selectedDrawableResizeAnimation, titleLabelResizeAnimation, descriptionLabelResizeAnimation]);
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_4_SelectingPois/js/marker.js#L163-L190">GitHub</a>
</div>

<p>Launch the <a href="../Reference/JavaScript%20API/classes/AnimationGroup.html"><code>AR.AnimationGroup</code></a> using the <code>start</code> function.</p>
<pre><code class="lang-js">    marker.animationGroup_selected.start();
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_4_SelectingPois/js/marker.js#L156">GitHub</a>
</div>

<p>In the function <code>Marker.prototype.getOnClickTrigger</code> the selection functions are only called if no animation is currently running:</p>
<pre><code class="lang-js">if (!Marker.prototype.isAnyAnimationRunning(marker)) {
    if (marker.isSelected) {

        Marker.prototype.setDeselected(marker);

    } else {
        Marker.prototype.setSelected(marker);
        try {
            World.onMarkerSelected(marker);
        } catch (err) {
            alert(err);
        }

    }
    } else {
        AR.logger.debug(&#39;a animation is already running&#39;);
    }
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_4_SelectingPois/js/marker.js#L86-L102">GitHub</a>
</div>

<p>Create an <a href="../Reference/JavaScript%20API/classes/ImageResource.html"><code>AR.ImageResource</code></a> referencing the image that should be displayed for a direction indicator. Then create an <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> using the <a href="../Reference/JavaScript%20API/classes/ImageResource.html"><code>AR.ImageResource</code></a>. Set options regarding the offset and anchor of the image so that it will be displayed correctly on the edge of the screen.</p>
<pre><code class="lang-js">this.directionIndicatorDrawable = new AR.ImageDrawable(World.markerDrawable_directionIndicator, 0.5, {
    enabled: false
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_4_SelectingPois/js/marker.js#L59-L62">GitHub</a>
</div>

<p>The last step is to define the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> as an <code>indicator</code> target on the marker <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a>. The direction indicator is displayed automatically when necessary. <code>AR.Drawable</code> subclasses (e.g. <a href="../Reference/JavaScript%20API/classes/Circle.html"><code>AR.Circle</code></a>) can be used as direction indicators.</p>
<pre><code class="lang-js">this.markerObject = new AR.GeoObject(markerLocation, {
    drawables: {
        cam: [    this.markerDrawable_idle, 
                this.markerDrawable_selected, 
                this.titleLabel, 
                this.descriptionLabel
             ],
            indicator: this.directionIndicatorDrawable
        }
    });
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/4_PointOfInterest_4_SelectingPois/js/marker.js#L67-L75">GitHub</a>
</div>

<h2 id="retrieving-poi-data">Retrieving POI Data</h2>
<p>There are several ways to request and work with POI detail information in an ARchitect World.
Depending on your application and use case, one might fit better than the other.</p>
<p>This sample consists of three parts</p>
<ol>
<li><a href="#applicationmodel">From Application Model</a></li>
<li><a href="#local">From a Local Resource </a></li>
<li><a href="#webservice">From a Webservice</a></li>
</ol>
<p><a id="applicationmodel"></a></p>
<h3 id="from-application-model-1-3-">From Application Model (1/3)</h3>
<p>Besides loading data from assets it is also possible to load data from a database, or to create it in native code. Use the platform common way to create JSON Objects of your data and use <code>architectView.callJavaScript()</code> to pass them to the ARchitect World&#39;s JavaScript.</p>
<p>Have a look at <code>SampleCamContentFromNativeActivity.java</code> to get a better understanding of how data can be injected to JavaScript.</p>
<p><a id="local"></a></p>
<h3 id="from-a-local-resource-2-3-">From a Local Resource (2/3)</h3>
<p>In case the data of your ARchitect World is static the content should be stored within the application.
Create a JavaScript file (e.g. <code>myjsondata.js</code>) where a globally accessible variable is defined:</p>
<pre><code class="lang-js">var myJsonData = …[YOUR-JSON-DATA]
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/5_ObtainPoiData_2_FromLocalResource/js/myjsondata.js#L1">GitHub</a>
</div>

<p>Include the JavaScript in the ARchitect Worlds HTML by adding <code>&lt;script src=&quot;js/myjsondata.js&quot;/&gt;</code> to make POI information available anywhere in your JavaScript.</p>
<pre><code class="lang-js">// request POI data
requestDataFromLocal: function requestDataFromLocalFn(lat, lon) {
    World.loadPoisFromJsonData(myJsonData);
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/5_ObtainPoiData_2_FromLocalResource/js/fromlocalresource.js#L103-L114">GitHub</a>
</div>

<p><em>Note: This sample uses static POI data and overwrites latitude and longitude values using <code>Helper.bringPlacesToUser</code>, you must remove this line to avoid this.</em></p>
<p><a id="webservice"></a></p>
<h3 id="from-a-webservice-3-3-">From a Webservice (3/3)</h3>
<p><a href="http://jquery.com/" target="_top">JQuery</a> provides a number of tools to load data from a remote origin. It is highly recommended to use the JSON format for POI information. Requesting and parsing is done in a few lines of code.</p>
<p>Use e.g. <code>AR.context.onLocationChanged = World.locationChanged;</code> to define the method invoked on location updates. In this sample POI information is requested after the very first location update. Note: You may set <code>AR.context.onLocationChanged = null</code> afterwards to no longer receive location updates in <code>World.locationChanged</code>.</p>
<p>It is recommended to store server information separately.</p>
<pre><code class="lang-js">// holds server information
var ServerInformation = {
    // sample service returning dummy POIs
    POIDATA_SERVER: &quot;http://example.wikitude.com/GetSamplePois/&quot;,
    POIDATA_SERVER_ARG_LAT: &quot;lat&quot;,
    POIDATA_SERVER_ARG_LON: &quot;lon&quot;,
    POIDATA_SERVER_ARG_NR_POIS: &quot;nrPois&quot;
};
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/5_ObtainPoiData_3_FromWebservice/js/fromwebservice.js#L2-L7">GitHub</a>
</div>

<p>Ensure that the server returns valid JSON and it is escaped properly (e.g. special characters in POI name…). </p>
<p>The server response is passed over to <code>World.loadPoisFromJsonData(poiData)</code>, where the creation of markers and their camera representation is defined.</p>
<pre><code class="lang-js">
// location updates
locationChanged: function locationChangedFn(lat, lon, alt, acc) {

    /* Request data from server only once*/
    if (!World.alreadyRequestedData) {
        World.requestDataFromServer(lat, lon);
        World.alreadyRequestedData = true;
    }
},
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/5_ObtainPoiData_3_FromWebservice/js/fromwebservice.js#L73-L80">GitHub</a>
</div>

<pre><code class="lang-js">
// request POI data
requestDataFromServer: function requestDataFromServerFn(lat, lon) {

    // set helper var to avoid requesting places while loading
    World.isRequestingData = true;
    World.updateStatusMessage(&#39;Requesting places from web-service&#39;);

    // server-url to JSON content provider
    var serverUrl = ServerInformation.POIDATA_SERVER + &quot;?&quot; + ServerInformation.POIDATA_SERVER_ARG_LAT + &quot;=&quot; + lat + &quot;&amp;&quot; + ServerInformation.POIDATA_SERVER_ARG_LON + &quot;=&quot; + lon + &quot;&amp;&quot; + ServerInformation.POIDATA_SERVER_ARG_NR_POIS + &quot;=20&quot;;

    var jqxhr = $.getJSON(serverUrl, function(data) {
        World.loadPoisFromJsonData(data);
    })
        .error(function(err) {
            World.updateStatusMessage(&quot;Invalid web-service response.&quot;, true);
            World.isRequestingData = false;
        })
        .complete(function() {
            World.isRequestingData = false;
        });
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/5_ObtainPoiData_3_FromWebservice/js/fromwebservice.js#L115-L137">GitHub</a>
</div>

<h2 id="browsing-pois">Browsing POIs</h2>
<p>Displaying numerous POIs in the camera is a challenge. How many POIs should be offered? How to deal with POIs in same direction? What is the maximum range to show POIs and how to display a long description?
The following example cover frequently asked questions related to the POI browser use case and consists of five parts plus a bonus section</p>
<ol>
<li><a href="#presentingdetails">Presenting Details</a></li>
<li><a href="#poiarradar">POI and AR Radar</a></li>
<li><a href="#limitingvisiblepois">Limiting Visible POIs</a></li>
<li><a href="#reloadingpoidata">Reloading POI Data</a></li>
<li><a href="#nativedetailscreen">Native Detail Screen</a></li>
<li><a href="#capturescreen">Capture Screen Bonus</a></li>
</ol>
<p><a id="presentingdetails"></a></p>
<h3 id="presenting-details-1-6-">Presenting Details (1/6)</h3>
<p>POIs usually have a name and sometimes a quite long description. Depending on your content type you may e.g. display a marker with its name and cropped description but allow the user to get more information after selecting it.</p>
<p><img src="images/sample_poi_details.jpg" alt=""></p>
<p><a href="http://jquerymobile.com/" target="_top">jQuery Mobile</a> is an easy way to create appealing user interfaces for mobile devices. It takes the &quot;write less, do more&quot; mantra to the next level: Instead of writing unique apps for each mobile device or OS, the jQuery mobile framework allows you to design a single highly-branded web site or application that will work on all popular smartphones, tablets, and desktop platforms (quote from their website).
We recommend to use jQuery mobile for the implementation of the UI in the augmented reality view. It is well documented and can even be bundled into the app or hosted on your own web server.</p>
<p>In this sample a POI detail panel appears when pressing a cam-marker (the blue box with title &amp; description), compare <strong>index.html</strong> in the sample&#39;s directory.</p>
<pre><code>&lt;!-- panel containing POI detail information --&gt;
&lt;div data-role=&quot;panel&quot; id=&quot;panel-poidetail&quot; data-position=&quot;right&quot; data-display=&quot;overlay&quot; style=&quot;background-color:#F0F0F0;&quot; data-theme=&quot;c&quot;&gt;

&lt;!-- header with &quot;close&quot; button --&gt;
&lt;div data-role=&quot;header&quot; data-theme=&quot;c&quot;&gt;
    &lt;h1&gt;Details&lt;/h1&gt;
    &lt;a href=&quot;#header&quot; data-rel=&quot;close&quot;&gt;Close&lt;/a&gt;
&lt;/div&gt;

&lt;!-- content of POI detail page, you may also add thumbnails etc. here if you like --&gt;
&lt;div data-role=&quot;content&quot;&gt;
    &lt;!-- title --&gt;
    &lt;h3 id=&quot;poi-detail-title&quot;&gt;&lt;/h3&gt;

    &lt;!-- description --&gt;
    &lt;h4 id=&quot;poi-detail-description&quot;&gt;&lt;/h4&gt;

    &lt;!-- distance --&gt;
    &lt;h4&gt;Distance: &lt;a id=&quot;poi-detail-distance&quot;&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;/div&gt;
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_1_PresentingDetails/index.html#L53-L73">GitHub</a>
</div>

<p>When selecting a marker the content shown in the POI detail <code>div</code> is updated. At the same time the panel is animated from right to left.</p>
<p>To deselect the marker the <code>panelbeforeclose</code> event is used, compare <strong>presentingPoiDetails.js</strong></p>
<pre><code class="lang-js">onMarkerSelected: function onMarkerSelectedFn(marker) {

    World.currentMarker = marker;

    // update panel values
    $(&quot;#poi-detail-title&quot;).html(marker.poiData.title);
    $(&quot;#poi-detail-description&quot;).html(marker.poiData.description);

    var distanceToUserValue = (marker.distanceToUser &gt; 999) ? ((marker.distanceToUser / 1000).toFixed(2) + &quot; km&quot;) : (Math.round(marker.distanceToUser) + &quot; m&quot;);

    $(&quot;#poi-detail-distance&quot;).html(distanceToUserValue);

    // show panel
    $(&quot;#panel-poidetail&quot;).panel(&quot;open&quot;, 123);

    $(&quot;#panel-poidetail&quot;).on(&quot;panelbeforeclose&quot;, function(event, ui) {
    World.currentMarker.setDeselected(World.currentMarker);
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_1_PresentingDetails/js/presentingdetails.js#L106-L131">GitHub</a>
</div>

<p><a id="poiarradar"></a></p>
<h3 id="poi-and-ar-radar-2-6-">POI and AR Radar (2/6)</h3>
<p>It is recommended to give the user a hint where places are located in the user&#39;s vicinity. The easiest way to provide orientation assistance is an <a href="../Reference/JavaScript%20API/classes/radar.html"><code>AR.Radar</code></a> element. Every <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> (e.g. a cam marker) can have a representation in the radar element, usually indicated by a small dot.</p>
<p><img src="images/sample_poi_radar.jpg" alt=""></p>
<p>The representation of an <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> in the radar is defined in its drawables set (second argument of <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> constructor). Once <code>drawables.radar</code> is set the object is also shown on the radar e.g. as an <a href="../Reference/JavaScript%20API/classes/Circle.html"><code>AR.Circle</code></a>, compare <strong>marker.js</strong>:</p>
<pre><code class="lang-js">this.radarCircle = new AR.Circle(0.03, {
    horizontalAnchor: AR.CONST.HORIZONTAL_ANCHOR.CENTER,
    opacity: 0.8,
    style: {
        fillColor: &quot;#ffffff&quot;
    }
}); 
this.radardrawables = [];
this.radardrawables.push(this.radarCircle);
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_2_AddingRadar/js/marker.js#L64-L81">GitHub</a>
</div>

<p>Additionally create circles with a different color for the selected state, compare <strong>marker.js</strong>:</p>
<pre><code class="lang-js">this.radarCircleSelected = new AR.Circle(0.05, {
       horizontalAnchor: AR.CONST.HORIZONTAL_ANCHOR.CENTER,
       opacity: 0.8,
       style: {
           fillColor: &quot;#0066ff&quot;
       }
   });

this.radardrawablesSelected = [];
   this.radardrawablesSelected.push(this.radarCircleSelected);

this.markerObject = new AR.GeoObject(markerLocation, {
       drawables: {
           cam: [    this.markerDrawable_idle, 
                   this.markerDrawable_selected, 
                   this.titleLabel, 
                   this.descriptionLabel ],
           indicator: this.directionIndicatorDrawable,
           radar: this.radardrawables
       }
   });
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_2_AddingRadar/js/marker.js#L83-L95">GitHub</a>
</div>

<p>To highlight a selected marker in the radar update the drawables in the function </p>
<p><img src="images/sample_poi_focus_radar.jpg" alt=""> <img src="images/sample_poi_focus_radar_selected.jpg" alt=""></p>
<p><code>Marker.prototype.setSelected</code> and <code>Marker.prototype.setDeselected</code>, compare <strong>marker.js</strong>:</p>
<pre><code class="lang-js">marker.markerObject.drawables.radar = marker.radardrawablesSelected;
[...]
marker.markerObject.drawables.radar = marker.radardrawables;
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_2_AddingRadar/js/marker.js#L178-L188">GitHub</a>
</div>

<p>The position of the radar and its size are defined using a DOM element. In our example a <code>div</code> element with id <code>radarContainer</code>, compare <strong>index.html</strong>:</p>
<pre><code>&lt;div class=&quot;radarContainer_left&quot; id=&quot;radarContainer&quot;&gt;&lt;/div&gt;
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_2_AddingRadar/index.html#L49">GitHub</a>
</div>

<p>The size and position of the radar is defined in a css class, see <strong>poi-radar.css</strong>:</p>
<pre><code>/* position of POI-radar*/

.radarContainer_left {
    position:absolute;
    top:0px;
    left:0px;
    width:100px;
    height:100px;
}
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_2_AddingRadar/css/poi-radar.css#L7-L13">GitHub</a>
</div>

<p>We advise you to use an absolute position for the element which will be referred to the radar container. Keep in mind: In case the DOM element is updated on the fly via jQuery or responsive design use <code>AR.radar.notifyUpdateRadarPosition();</code> to force radar position/size updates, otherwise the very first position/size will be used.</p>
<p>The radar itself can be customized and should be implemented as a separate component in your JavaScript code, compare <strong>radar.js</strong>.</p>
<pre><code class="lang-js">var PoiRadar = {

    hide: function hideFn() {
        AR.radar.enabled = false;
    },

    show: function initFn() {

        // the div defined in the index.htm
        AR.radar.container = document.getElementById(&quot;radarContainer&quot;);

        // set the back-ground image for the radar
        AR.radar.background = new AR.ImageResource(&quot;assets/radar_bg.png&quot;);

        // set the north-indicator image for the radar 
        // (not necessary if you don&#39;t want to display a north-indicator)
        AR.radar.northIndicator.image = new AR.ImageResource(&quot;assets/radar_north.png&quot;);

        // center of north indicator and radar-points in the radar asset, 
        // usually center of radar is in the exact middle of the background, 
        // meaning 50% X and 50% Y axis --&gt; 0.5 for centerX/centerY
        AR.radar.centerX = 0.5;
        AR.radar.centerY = 0.5;

        AR.radar.radius = 0.3;
        AR.radar.northIndicator.radius = 0.0;

        AR.radar.enabled = true;
    },

    updatePosition: function updatePositionFn() {
        if (AR.radar.enabled) {
            AR.radar.notifyUpdateRadarPosition();
        }
    },

    // you may define some custom action when user pressed radar, 
    // e.g. display distance, custom filtering etc.
    clickedRadar: function clickedRadarFn() {
        alert(&quot;Radar Clicked&quot;);
    },

    setMaxDistance: function setMaxDistanceFn(maxDistanceMeters) {
        AR.radar.maxDistance = maxDistanceMeters;
    }
};
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_2_AddingRadar/js/radar.js#L1-L42">GitHub</a>
</div>

<p>Call the <code>PoiRadar.show</code> function to activate the radar component. You may even define a click action if requested, compare <strong>addingradar.js</strong>:</p>
<pre><code class="lang-js">// show radar &amp; set click-listener
PoiRadar.show();
$(&#39;#radarContainer&#39;).unbind(&#39;click&#39;);
$(&quot;#radarContainer&quot;).click(PoiRadar.clickedRadar);
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_2_AddingRadar/js/addingradar.js#L34-L38">GitHub</a>
</div>

<p><a id="limitingvisiblepois"></a></p>
<h3 id="limiting-visible-pois-3-6-">Limiting Visible POIs (3/6)</h3>
<p>Users are sometimes only interested to see POIs within a certain range. This sample provides an additional button in the titlebar button to allow users to change the range of interest.</p>
<p><img src="images/sample_poi_range.jpg" alt=""></p>
<p>First of all add a button in the titlebar</p>
<p><strong>index.html</strong></p>
<pre><code>&lt;!-- header of UI holding feature buttons --&gt;
&lt;div id =&quot;header-status&quot; data-role=&quot;header&quot; data-position=&quot;fixed&quot; data-theme=&quot;c&quot;&gt;
    &lt;a href=&quot;javascript: World.showRange();&quot; data-icon=&quot;gear&quot; data-inline=&quot;true&quot; data-mini=&quot;true&quot;&gt;Range&lt;/a&gt;
    &lt;h1&gt;&lt;/h1&gt;
&lt;/div&gt;
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_3_LimitingRange/index.html#L43-L47">GitHub</a>
</div>

<p>Afterwards define the panel layout for distance range. In this case the current range in meters and the number of visible POIs is shown in the panel.</p>
<p><strong>index.html</strong></p>
<pre><code>&lt;!-- range panel --&gt;
&lt;div data-role=&quot;panel&quot; id=&quot;panel-distance&quot; data-position=&quot;left&quot; data-display=&quot;overlay&quot; style=&quot;background-color:#F0F0F0;&quot; data-theme=&quot;c&quot;&gt;

    &lt;!-- header with close button --&gt;
    &lt;div data-role=&quot;header&quot; data-theme=&quot;c&quot;&gt;
        &lt;h1&gt;Range&lt;/h1&gt;
        &lt;a href=&quot;#header&quot; data-rel=&quot;close&quot;&gt;Close&lt;/a&gt;
    &lt;/div&gt;

    &lt;!-- distance information, calculated/updated in code  --&gt;
    &lt;div data-role=&quot;content&quot;&gt;

    &lt;!-- Range in m/km--&gt;
    &lt;h4&gt; Range: &lt;a id=&quot;panel-distance-value&quot;&gt;&lt;/a&gt;&lt;/h4&gt;

    &lt;!-- Amount of visible places --&gt;
    &lt;h4&gt; Visible: &lt;a id=&quot;panel-distance-places&quot;&gt;&lt;/a&gt;&lt;/h4&gt;

    &lt;!-- default slider --&gt;
    &lt;input id=&quot;panel-distance-range&quot; type=&quot;range&quot; data-highlight=&quot;true&quot; name=&quot;rangeSlider&quot; min=&quot;0&quot; max=&quot;100&quot; value=&quot;100&quot; data-show-value=&quot;false&quot; step=&quot;5&quot; data-popup-enabled=&quot;false&quot;&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_3_LimitingRange/index.html#L94-L115">GitHub</a>
</div>

<p>The function <code>World.updateRangeValues</code> is executed every time a user changes the slider value.
Besides proper calculation of the maximum distance and total number of visible places <a href="../Reference/JavaScript%20API/classes/context.html#property_scene.cullingDistance"><code>AR.context.scene.cullingDistance</code></a> and <code>PoiRadar.setMaxDistance</code> are executed to update rendering of markers and drawables in the radar, compare <strong>limitingrange.js</strong></p>
<pre><code class="lang-js">    // updates values show in &quot;range panel&quot;
updateRangeValues: function updateRangeValuesFn() {

    // get current slider value (0..100);
    var slider_value = $(&quot;#panel-distance-range&quot;).val();

    // max range relative to the maximum distance of all visible places
    var maxRangeMeters = Math.round(World.getMaxDistance() * (slider_value / 100));

    // range in meters including metric m/km
    var maxRangeValue = (maxRangeMeters &gt; 999) ? ((maxRangeMeters / 1000).toFixed(2) + &quot; km&quot;) : (Math.round(maxRangeMeters) + &quot; m&quot;);

    // number of places within max-range
    var placesInRange = World.getNumberOfVisiblePlacesInRange(maxRangeMeters);

    // update UI labels accordingly
    $(&quot;#panel-distance-value&quot;).html(maxRangeValue);
    $(&quot;#panel-distance-places&quot;).html((placesInRange != 1) ? (placesInRange + &quot; Places&quot;) : (placesInRange + &quot; Place&quot;));

    // update culling distance, so only places within given range are rendered
    AR.context.scene.cullingDistance = Math.max(maxRangeMeters, 1);

    // update radar&#39;s maxDistance so radius of radar is updated too
    PoiRadar.setMaxDistance(Math.max(maxRangeMeters, 1));
},

// returns number of places with same or lower distance than given range
getNumberOfVisiblePlacesInRange: function getNumberOfVisiblePlacesInRangeFn(maxRangeMeters) {

    // sort markers by distance
    World.markerList.sort(World.sortByDistanceSorting);

    // loop through list and stop once a placemark is out of range ( -&gt; very basic implementation )
    for (var i = 0; i &lt; World.markerList.length; i++) {
        if (World.markerList[i].distanceToUser &gt; maxRangeMeters) {
            return i;
        }
    };

    // in case no placemark is out of range -&gt; all are visible
    return World.markerList.length;
},
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_3_LimitingRange/js/limitingrange.js#L162-L203">GitHub</a>
</div>

<p>The position of the radar component can be updated using another CSS style (using e.g. <code>removeClass</code> and <code>addClass</code> of jQuery) and calling <code>PoiRadar.updatePosition();</code>. In this sample the radar element moves to the right when the distance panel. Compare <strong>limitingrange.js</strong></p>
<pre><code class="lang-js">handlePanelMovements: function handlePanelMovementsFn() {

    $(&quot;#panel-distance&quot;).on(&quot;panelclose&quot;, function(event, ui) {
        $(&quot;#radarContainer&quot;).addClass(&quot;radarContainer_left&quot;);
        $(&quot;#radarContainer&quot;).removeClass(&quot;radarContainer_right&quot;);
        PoiRadar.updatePosition();
    });

    $(&quot;#panel-distance&quot;).on(&quot;panelopen&quot;, function(event, ui) {
        $(&quot;#radarContainer&quot;).removeClass(&quot;radarContainer_left&quot;);
        $(&quot;#radarContainer&quot;).addClass(&quot;radarContainer_right&quot;);
        PoiRadar.updatePosition();
    });
},
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_3_LimitingRange/js/limitingrange.js#L207-L217">GitHub</a>
</div>

<p>The <code>World.showRange</code> function is executed when a user presses the <code>Range</code> button.</p>
<pre><code class="lang-js">// display range slider
showRange: function showRangeFn() {
    if (World.markerList.length &gt; 0) {

        // update labels on every range movement
        $(&#39;#panel-distance-range&#39;).change(function() {
            World.updateRangeValues();
        });

        World.updateRangeValues();
        World.handlePanelMovements();

        // open panel
        $(&quot;#panel-distance&quot;).trigger(&quot;updatelayout&quot;);
        $(&quot;#panel-distance&quot;).panel(&quot;open&quot;, 1234);
    } else {

        // no places are visible, because the are not loaded yet
        World.updateStatusMessage(&#39;No places available yet&#39;, true);
    }
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_3_LimitingRange/js/limitingrange.js#L221-L240">GitHub</a>
</div>

<p><a id="reloadingpoidata"></a></p>
<h3 id="reloading-poi-data-4-6-">Reloading POI Data (4/6)</h3>
<p>You may need to reload POI information because of user movements or manually for various reasons. In this example POIs are reloaded when user presses the refresh button. The button is defined in <strong>index.html</strong> and calls <code>World.reloadPlaces()</code> on click.</p>
<pre><code>&lt;a href=&quot;javascript: World.reloadPlaces()&quot; data-icon=&quot;refresh&quot; &gt;Reload&lt;/a&gt;
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_4_ReloadingContent/index.html#L46">GitHub</a>
</div>

<p>The implementation of <code>World.reloadPlaces()</code> is part of the ARchitect World (<strong>reloadingPois.js</strong>) and executes <code>World.requestDataFromServer</code> which retrieves data according to the user&#39;s current location from a web service.</p>
<p>Sidenote: In certain circumstances your web service may not be available or other connection issues can occur. To notify the user about connection problems a status message is updated, In your own implementation you may e.g. use an info popup or similar.</p>
<pre><code class="lang-js">var World = {

    […]

    // reload places from content source
    reloadPlaces: function reloadPlacesFn() {
        if (!World.isRequestingData) {
            if (World.userLocation) {
                World.requestDataFromServer(World.userLocation.latitude,
                                            World.userLocation.longitude);
            } else {
                World.updateStatusMessage(&#39;Unknown user-location.&#39;, true);
            }
        } else {
            World.updateStatusMessage(&#39;Already requesting places...&#39;, true);
        }
    }

    […]
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_4_ReloadingContent/js/reloadingcontent.js#L251-L262">GitHub</a>
</div>

<p><a id="nativedetailscreen"></a></p>
<h3 id="displaying-native-detail-screen-5-6-">Displaying Native Detail Screen (5/6)</h3>
<p>It may make sense to display POI details in your native style. In this sample a very simple native screen opens when user presses the &#39;More&#39; button in HTML. This demoes the interaction between JavaScript and native code.</p>
<p><img src="images/sample_poi_native.jpg" alt=""></p>
<p>A More button is added to <strong>index.html</strong> which calls the function <code>World.onPoiDetailMoreButtonClicked</code>.</p>
<pre><code>&lt;!-- more button--&gt;
&lt;a href=&quot;javascript: World.onPoiDetailMoreButtonClicked();&quot; 
   data-role=&quot;button&quot; data-icon=&quot;arrow-r&quot; data-iconpos=&quot;right&quot; data-inline=&quot;true&quot;&gt;
    More
&lt;/a&gt;
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_5_NativeDetailScreen/index.html#L96">GitHub</a>
</div>

<p><code>World.onPoiDetailMoreButtonClicked</code> is implemented in <strong>nativedetailscreen.js</strong> and executes <code>document.location = architectsdk://...</code>. The urlListener of the native project intercepts this call and parses the arguments. This is the only way to pass information from JavaScript to your native code. Ensure to properly encode and decode arguments.</p>
<pre><code class="lang-js">var World = {
    […]

    // user clicked &quot;More&quot; button in POI-detail panel -&gt; fire event to open native screen
    onPoiDetailMoreButtonClicked: function onPoiDetailMoreButtonClickedFn() {

        var currentMarker = World.currentMarker;
        var architectSdkUrl = &quot;architectsdk://markerselected?id=&quot; +
                            encodeURIComponent(currentMarker.poiData.id) + 
                            &quot;&amp;title=&quot; + 
                            encodeURIComponent(currentMarker.poiData.title) + 
                            &quot;&amp;description=&quot; + 
                            encodeURIComponent(currentMarker.poiData.description);
        document.location = architectSdkUrl;

    }

    […]
}
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_5_NativeDetailScreen/js/nativedetailscreen.js#L105-L117">GitHub</a>
</div>

<p>Please have a look at the <a href="#nativedetailscreenplatform">this</a> section which describes the custom url scheme native part.</p>
<p>The <code>ArchitectUrlListener</code> interface allows you to exchange information between the JavaScript and the native code. It needs to be implemented whenever you want to communicate from JavaScript with the native code. </p>
<p>The method  <code>urlWasInvoked(String uriString)</code> is called whenever the document.location in the Javascript file is the to the scheme <code>architectsdk://</code> with any additional information encoded as URI components.
The parameter <em>uriString</em> represents the information as a string and can be parsed e.g. with <code>Uri invokedUri = Uri.parse(uriString);</code></p>
<h5 id="sample-usage-">Sample usage:</h5>
<pre><code>            // fetch e.g. document.location = &quot;architectsdk://markerselected?id=1&quot;;
            public boolean urlWasInvoked(String uriString) {
                Uri invokedUri = Uri.parse(uriString);
                if (&quot;markerselected&quot;.equalsIgnoreCase(invokedUri.getHost())) {
                        final Intent poiDetailIntent = new Intent(SampleCamHandlePoiDetailActivity.this, SamplePoiDetailActivity.class);
                        poiDetailIntent.putExtra(SamplePoiDetailActivity.EXTRAS_KEY_POI_ID, String.valueOf(invokedUri.getQueryParameter(&quot;id&quot;)) );
                        poiDetailIntent.putExtra(SamplePoiDetailActivity.EXTRAS_KEY_POI_TITILE, String.valueOf(invokedUri.getQueryParameter(&quot;title&quot;)) );
                        poiDetailIntent.putExtra(SamplePoiDetailActivity.EXTRAS_KEY_POI_DESCR, String.valueOf(invokedUri.getQueryParameter(&quot;description&quot;)) );
                        SampleCamHandlePoiDetailActivity.this.startActivity(poiDetailIntent);
                        return true;
                }
                return false;
            }
</code></pre><p>Please refer to the <strong>presentingdetails.js</strong> file for more details about the JavaScript part.</p>
<p><a id="capturescreen"></a></p>
<h3 id="capture-screen-bonus-6-6-">Capture Screen Bonus (6/6)</h3>
<p>This sample shows you how to use the function <code>captureScreen</code>  to share a snapshot with your friends. Concept of interaction between JavaScript and native code is same as in the POI Detail page sample but the <code>urlListener</code> now handles picture sharing instead. The &quot;Snapshot&quot;-button is on top right in the title bar. Once clicked the current screen is captured and user is prompted to share it.</p>
<pre><code> &lt;!-- header of UI holding feature buttons --&gt;
        &lt;div id =&quot;header-status&quot; data-role=&quot;header&quot; data-position=&quot;fixed&quot; data-theme=&quot;c&quot;&gt;
            &lt;a href=&quot;javascript: World.showRange();&quot; data-icon=&quot;gear&quot; data-inline=&quot;true&quot; data-mini=&quot;true&quot;&gt;Range&lt;/a&gt;
            &lt;a href=&quot;javascript: World.captureScreen()&quot; data-icon=&quot;refresh&quot; &gt;Snapshot&lt;/a&gt;
            &lt;h1&gt;&lt;/h1&gt;
        &lt;/div&gt;
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_5_NativeDetailScreen/js/nativedetailscreen.js#L105-L117">GitHub</a>
</div>

<p>Handling of picture sharing is done in native code.</p>
<pre><code class="lang-js">    // tell native (urlListener) that user pressed &#39;Snapshot&#39; button
    captureScreen: function captureScreenFn() {
        document.location = &quot;architectsdk://button?action=captureScreen&quot;;
    },
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/6_BrowsingPois_6_Bonus-CaptureScreen/js/capturescreen.js#L275-L280">GitHub</a>
</div>

<p><img src="images/sample_poi_snapshot.jpg" alt="">
 No newline at end of file</p>

<h2 id="video-drawables">Video Drawables</h2>
<p>Besides images, text and HTML content you are able to display videos in augmented reality using the Wikitude SDK. With the help of <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html"><code>AR.VideoDrawables</code></a> you can add a video on top of any target image (<a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>) or have it displayed at any geo location (<a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a>). Like any other drawable you can position, scale, rotate and change the opacity of the video drawable.</p>
<p>To view the sample you can use the image in <a href="targetimages.html">on this page</a></p>
<h3 id="supported-devices">Supported Devices</h3>
<p>In general, video drawables are fully supported on devices running iOS 6+ and Android 4.0+. Other devices will still play back the video but only in fullscreen mode as a fall-back solution. </p>
<ul>
<li>iOS 6.0 or newer: full support</li>
<li>Android 4.0 or newer: full support</li>
<li>Android 3.x or older: only fullscreen videos</li>
</ul>
<p>The Wikitude SDK is detecting the appropriate mode accordingly.</p>
<h3 id="multiple-video-drawables">Multiple Video Drawables</h3>
<p>Android has a limit of how many video drawables can be instantiated at the same time. Every time a Video Drawable object is created, Android will create a MediaPlayer for it and allocates memory. Therefor it is not possible to create more than 4 VideoDrawables at the same time.</p>
<h3 id="supported-video-codecs-and-hosting-services">Supported Video Codecs and Hosting Services</h3>
<p>To support all platforms make sure to use a H.264 encoded video with a maximum resolution of 720p (1280x720 pixel).</p>
<p>H.264 defines different profiles. Make sure that you are using either one of the following</p>
<ul>
<li>Baseline</li>
<li>Extended</li>
<li>Main</li>
</ul>
<p>If the profile differs Android devices will most certainly misbehave (fail to play or crash entirely) when playing back those videos. </p>
<p>Keep in mind that URLs from video hosting services need to point directly to the H.264 encoded video file. Standard YouTube and Vimeo URLs (like <a href="http://www.youtube.com/watch?v=bX98XNv8VL4">http://www.youtube.com/watch?v=bX98XNv8VL4</a>) will <strong>not</strong> work for this purpose. </p>
<p>If you like to add a YouTube video, which is then played full-screen in the native player, rather use an <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> showing a poster or play-button and add the URL to the YouTube video to the <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html#event_onClick"><code>onClick</code></a> trigger. Similar to what we do in the <a href="clientrecognition.html#interactivity">client recognition sample</a>.</p>
<h3 id="video-sample">Video Sample</h3>
<p>The following examples will demonstrate how to choose a proper video and how to augment a target image. Furthermore it shows how to react on playback states and concludes with how to use transparent videos.</p>
<p>This sample consists of four parts</p>
<ol>
<li><a href="#choosingvideo">Select a Video and add it to a Target Image</a></li>
<li><a href="#playback">Control Video Playback</a></li>
<li><a href="#snappingvideo">Snapping Video</a></li>
<li><a href="#transparentvideo">Bonus: Transparent Video</a></li>
</ol>
<p><a id="choosingvideo"></a></p>
<h3 id="select-a-video-and-add-it-to-a-target-image-1-4-">Select a Video and add it to a Target Image (1/4)</h3>
<p>The video we use for this example is &quot;video.mp4&quot;. As with all resources the video can be loaded locally from the application bundle or remotely from any server. In this example the video file is already bundled with the application.</p>
<p>To view the sample you can use the images <a href="targetimages.html">on this page</a>. </p>
<p>With the video URL at hand the drawable is created as follows:</p>
<pre><code class="lang-js">// Create video drawable
var video = new AR.VideoDrawable(&quot;assets/video.mp4&quot;, 0.5, {
    offsetX: 0.2,
    offsetY: 0.2
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/7_Video_1_SimpleVideo/js/simplevideo.js#L23-L25">GitHub</a>
</div>


<p>The URL and the size are required when creating a new <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html"><code>AR.VideoDrawable</code></a>. Optionally the <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#property_offsetX"><code>offsetX</code></a> and <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#property_offsetY"><code>offsetY</code></a> parameters are set to position the video on the target. The values for the offsets are again in SDUs (more information on the concept of SDUs <a href="sdu-dbs.html">here</a>). </p>
<p>Adding the video to the target image is straight forward and similar like adding any other drawable to an image target.</p>
<pre><code class="lang-js">var pageOne = new AR.Trackable2DObject(this.tracker, &quot;*&quot;, {
    drawables: {
        cam: video
    },
    onEnterFieldOfVision: function onEnterFieldOfVisionFn () {
        video.play(-1);
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/7_Video_1_SimpleVideo/js/simplevideo.js#L34-L42">GitHub</a>
</div>

<p><img src="images/simple_videos.jpg" style="width:300px;"></img> </p>
<p>To start the video immediately after the target is recognized we call <code>play</code> inside the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html#event_onEnterFieldOfVision"><code>onEnterFieldOfVision</code></a> trigger. Supplying <code>-1</code> to <code>play</code> tells the Wikitude SDK to loop the video infinitely. Choose any positive number to re-play it multiple times.</p>
<p>Note that we&#39;re using the wildcard <code>*</code>as the target name. This indicates that the trackable will match any target that is defined in the supplied tracker.</p>
<p><a id="playback"></a></p>
<h3 id="control-video-playback-2-4-">Control Video Playback (2/4)</h3>
<p>The class <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html"><code>AR.VideoDrawable</code></a> offers functions and triggers to control playback of the video and get notified of playback states. The following example makes use of the triggers and states to display an image of a play button on top of the target. Once the user clicks the play button the video starts to play. Additionally we pause and resume the video whenever the target is lost so the user does not miss any video content when looking away.</p>
<p>To view the sample you can use the image in <a href="targetimages.html">on this page</a></p>
<pre><code class="lang-js">// Create video drawable
var video = new AR.VideoDrawable(&quot;assets/video.mp4&quot;, 0.5, {
    offsetX: 0.2,
    offsetY: 0.2,
    onLoaded: function videoLoaded() {
        playButton.enabled = true;
    },
    onPlaybackStarted: function videoPlaying () {
        playButton.enabled = false;
        video.enabled = true;
    },
    onFinishedPlaying: function videoFinished () {
        playButton.enabled = true;
        video.playing = false;
        video.enabled = false;
    },
    onClick: function videoClicked () {
        if (video.playing) {
            video.pause();
            video.playing = false;
            playButton.enabled = true;
        } else {
            video.resume();
            video.playing = true;
            playButton.enabled = true;
        }
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/7_Video_2_PlaybackStates/js/playbackstates.js#L42-L67">GitHub</a>
</div>

<p>As before the video is positioned on the target with the <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#property_offsetX"><code>offsetX</code></a> and <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#property_offsetY"><code>offsetY</code></a> properties. Additionally functions are assigned to the <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#event_onLoaded"><code>onLoaded</code></a>, <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#event_onPlaybackStarted"><code>onPlaybackStarted</code></a> and <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#event_onFinishedPlaying"><code>onFinishedPlaying</code></a> triggers. The <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#event_onLoaded"><code>onLoaded</code></a> trigger fires once the video is ready for playback and the <code>playButton</code> is enabled. The <code>playButton</code> is an <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> defined as follows:</p>
<pre><code class="lang-js">// Create play button
var playButtonImg = new AR.ImageResource(&quot;assets/playButton.png&quot;);
var playButton = new AR.ImageDrawable(playButtonImg, 0.2, {
    enabled: false,
    onClick: function playButtonClicked() {
        video.play(1);
        video.playing = true;
    },
    offsetX: video.offsetX,
    offsetY: video.offsetY
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/7_Video_2_PlaybackStates/js/playbackstates.js#L17-L27">GitHub</a>
</div>

<p>Once the user clicks the button the video is played once: <code>video.play(1)</code>. Starting the playback fires the <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#event_onPlaybackStarted"><code>onPlaybackStarted</code></a> trigger that in this example hides the <code>playButton</code>. When playback finishes the <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#event_onFinishedPlaying"><code>onFinishedPlaying</code></a> trigger is called that shows the <code>playButton</code> again.</p>
<p>To give the user the possibility to pause the video the <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html"><code>AR.VideoDrawable&#39;s</code></a> click trigger is used. If the video is playing and the user is clicking the function <code>pause()</code> is called which then pauses playback. Clicking the video again resumes playback.</p>
<p>Similar to the user clicking on the video we want to pause/resume the playback if the target image is lost - as this means  the user is currently not actively watching the video. To  accomplish this the <code>onEnterFieldOfVision</code> and <code>onExitFieldOfVision</code> triggers of the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> are used:</p>
<pre><code class="lang-js">var pageOne = new AR.Trackable2DObject(this.tracker, &quot;*&quot;, {
    drawables: {
        cam: [video, playButton]
    },
    onEnterFieldOfVision: function onEnterFieldOfVisionFn () {
        if (video.playing) {
            video.pause();
        }
    },
    onExitFieldOfVision: function onExitFieldOfVisionFn () {
        if (video.playing) {
            video.resume();
        }
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/7_Video_2_PlaybackStates/js/playbackstates.js#L78-L93">GitHub</a>
</div>

<p>This concludes the example showing you how to control the playback of a <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html"><code>AR.VideoDrawable</code></a>. Have a look at the <a href="../Reference/JavaScript%20API">API Reference</a> for more details on each of the functions and triggers.</p>
<p><a id="snappingvideo"></a></p>
<h3 id="snapping-video-3-4-">Snapping Video (3/4)</h3>
<p>In the <a href="#playback">previous example</a> we used several triggers to pause and resume video playback when the target image is lost so that the user doesn&#39;t miss any video content while looking away. In this example we take this approach a little further and do not pause and resume video playback but instead snap the video onto the screen so that it is still visible even when the target image is lost.
To do so the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> offers several <code>snapToScreen</code> settings. In this example we use the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html#property_snapToScreen.enableOnExitFieldOfVision"><code>snapToScreen.enabledOnExitFieldOfVision</code></a> property to automatically snap all cam drawables onto the screen when the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html#event_onExitFieldOfVision"><code>onExitFieldOfVision</code></a> event occurs. To disable snapping when the target image is visible again we use the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html#property_snapToScreen.enabled"><code>snapToScreen.enabled</code></a> property and set it to <code>false</code> in the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html#event_onEnterFieldOfVision"><code>onEnterFieldOfVision</code></a> event. Doing so will display all cam drawables on the target image again.</p>
<pre><code class="lang-js">this.pageOne = new AR.Trackable2DObject(this.tracker, &quot;*&quot;, {
    drawables: {
        cam: [this.video, playButton]
    },
    onEnterFieldOfVision: function onEnterFieldOfVision() {
        World.pageOne.snapToScreen.enabled = false;
    },
    snapToScreen: {
        enabledOnExitFieldOfVision: true,
        snapContainer: document.getElementById(&#39;snapContainer&#39;)
    }
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/7_Video_3_SnappingVideo/js/snappingvideo.js#L80-L92">GitHub</a>
</div>


<p>The snap position is defined through a <code>div</code> element in your HTML source. The position and size of the <code>div</code> will affect the appearance of all cam drawables in the snapped state. It&#39;s important to update the <code>div</code> for both orientations, portrait and landscape, so that the augmentations will appear as expected. This example uses css to adopt the <code>div</code> for different device orientations.</p>
<p><a id="transparentvideo"></a></p>
<h3 id="bonus-transparent-video-4-4-">Bonus: Transparent video (4/4)</h3>
<p>This bonus example shows you how to add transparent videos on top of a target. Transparent videos require some extra preparation work.</p>
<p>Summarizing the required steps, here is what you need to do in order to use transparent videos in a simple list. We are describing each of the steps in more detail.</p>
<ol>
<li>Produce a green screen (chroma key) video</li>
<li>Edit that video using standard video processing software and remove the green screen. Export your result into a file format, which can handle alpha channel information (e.g. Apple ProRes 4444)</li>
<li>Convert the video from step 2 using the script in the tools folder</li>
<li>Add it to a target image</li>
</ol>
<p>Producing a transparent video is usually done using a green screen for filming and a technique called chroma key to replace the green background with transparency. Extensive information is available on the internet that should help you get started on this topic. </p>
<p>There are different video codecs that support alpha channels for motion picture and most of them will work as your raw material. We have extensively tested Apple ProRes 4444 codec for our own development and were satisfied with the results.</p>
<p>The Wikitude SDK can only render H.264 encoded videos, which is a codec that in practice does not support an alpha channel. The solution here is to include in the alpha channel in a separate (visible) part of the video. The video is split vertically consisting of a color and a alpha channel in the final video below each other. The following image shows how the preprocessing result should look like.</p>
<p><img src="images/video_h264_transparent.png" alt=""></p>
<p>The upper half of the image transports the color information for the final video while the lower half includes a grayscale representation of the alpha layer. White areas will be fully opaque and black areas will be fully transparent. If you are familiar with Photoshop, think of the lower half as a mask. Resulting videos have an height that is exactly twice as big as the input video.</p>
<p>To convert your raw video to a valid input video for the SDK we need to re-encode the video and automatically create the alpha mask. The script below uses <code>ffmpeg</code> to do so and wraps the necessary commands. Follow these simple steps:</p>
<h4 id="macos-x">MacOS X</h4>
<ol>
<li>Open the Terminal application</li>
<li>Input <code>cd &lt;SDK&gt;/tools/video/MacOSX</code>. Replace <code>&lt;SDK&gt;</code> with the path to the SDK folder</li>
<li>Execute <code>sh convert.sh &lt;input video&gt; &lt;output video&gt;</code>. Replace <code>&lt;input video&gt;</code> with the path to your transparent video and <code>&lt;output video&gt;</code> with the path where you want the output video to be stored.</li>
</ol>
<h4 id="windows">Windows</h4>
<ol>
<li>Open the Command Line</li>
<li><code>cd &lt;SDK&gt;\tools\video\Windows</code>. Replace <code>&lt;SDK&gt;</code> with the path to the SDK folder</li>
<li>Execute <code>convert.bat &lt;input video&gt; &lt;output video&gt;</code>. Replace <code>&lt;input video&gt;</code> with the path to your transparent video and <code>&lt;output video&gt;</code> with the path where you want the output video to be stored.</li>
</ol>
<p>This creates the required video with a vertically split color and alpha channel.</p>
<p>Adding the transparent H.264 video to a target image is easy and accomplished in the same way as any other video is added. Just make sure to set the <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html#method_isTransparent"><code>isTransparent</code></a> property of the <a href="../Reference/JavaScript%20API/classes/VideoDrawable.html"><code>AR.VideoDrawable</code></a> to <code>true</code>.</p>
<p>To view the sample you can use the image in <a href="targetimages.html">on this page</a></p>
<p><img src="images/transparent_video_1.jpg" style="width:300px;"></img> <img src="images/transparent_video.jpg" style="width:300px;"></img></p>
<pre><code class="lang-js">// Create a transparent video drawable
var video = new AR.VideoDrawable(&quot;assets/transparentVideo.mp4&quot;, 0.7, {
    offsetX: -0.2,
    offsetY: -0.12,
    isTransparent: true
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/7_Video_4_Bonus-TransparentVideo/js/transparentvideo.js#L52-L56">GitHub</a>
</div>

<h2 id="combine-client-recognition-and-pois">Combine Client Recognition and POIs</h2>
<p>The Wikitude SDK allows you to combine location based augmented reality scenes with vision based scenes to create a seamless experience for users. This tutorial will show you how to accomplish this and will provide you with additional advices.</p>
<p>Let’s start by creating the  <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ClientTracker</code></a> for recognizing a fictional store logo and assign it to an <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>.</p>
<pre><code class="lang-js">// Create the tracker to recognize a store logo
var trackerDataSetPath = &quot;assets/ShopLogo.wtc&quot;;
IrAndGeo.tracker = new AR.ClientTracker(trackerDataSetPath, {
    onLoaded: IrAndGeo.loadingStepDone,
    onError: IrAndGeo.errorLoading
});

// Create drawables to display on the recognized image
var logo = new AR.ImageDrawable(IrAndGeo.res.logo, 1.0, {
    zOrder: -1
});

// ...

IrAndGeo.menuDrawables = [logo, buttonDeal, buttonWeb, buttonStores];
IrAndGeo.dealDrawable = new AR.ImageDrawable(IrAndGeo.res.deal, 1.0, {
    enabled: false,
    onClick: IrAndGeo.hideDeal
});

// Create the object by defining the tracker, target name and its drawables
var trackable2DObject = new AR.Trackable2DObject(IrAndGeo.tracker, &quot;ShopLogo&quot;, {
    drawables: {
        cam: [logo, buttonDeal, buttonWeb, buttonStores, IrAndGeo.dealDrawable, IrAndGeo.model]
    },
   // ...
});
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/99_Demo_1_2dTrackingAndGeo/js/2dtrackingandgeo.js#L118-L156">GitHub</a>
</div>

<p><img src="images/irangeo_screenshot.jpeg" alt="Final result of overlaid images on top of shop logo." title="Final result of overlaid images on top of shop logo."></p>
<p>This is all it takes to display Drawables on top of a recognized image. The locations based augmented reality part can be accomplished similarly to any other ARchitect World.</p>
<pre><code class="lang-js">IrAndGeo.createMarker = function(lat, lon, name) {
    var loc = new AR.GeoLocation(lat, lon);
    var imageDrawable = new AR.ImageDrawable(IrAndGeo.res.marker, 2, {
        scale: 0.0,
        onClick: function() {
            alert(&quot;clicked&quot;);
        }
    });

    IrAndGeo.markerAnimations.push(new AR.PropertyAnimation(imageDrawable, &#39;scale&#39;, 0.0, 1.0, 1000, {
        type: AR.CONST.EASING_CURVE_TYPE.EASE_OUT_BOUNCE
    }));
    IrAndGeo.stores.push(new AR.GeoObject(loc, {
        drawables: {
            cam: imageDrawable
        },
        enabled: false
    }));
};
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/99_Demo_1_2dTrackingAndGeo/js/2dtrackingandgeo.js#L26-L49">GitHub</a>
</div>

<p>The method above creates a marker at the passed latitude and longitude. As with any other <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> the visual representation can be composed of
various drawables. The <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> is created with the value <code>enabled</code> set to <code>false</code> so it won’t be initially visible. To make it visible set the created
GeoObjects to <code>enabled</code> when an element on the image target is clicked.</p>
<p><img src="images/irgeo4_s.jpg" alt="Shop location visualized." title="Shop location visualized.">  </p>
<pre><code class="lang-js">IrAndGeo.showStores = function() {
    // enable all GeoObjects
    IrAndGeo.stores.forEach(function(x, idx) {
        x.enabled = true;
    });

    // ...
};
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/99_Demo_1_2dTrackingAndGeo/js/2dtrackingandgeo.js#L51-L63">GitHub</a>
</div>

<p>Combining vision based and locations based augmented reality is easy and straightforward. However, you should keep in mind that vision based augmented reality requires additional computing power (and thus battery power). Therefore, you should only create a  <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ClientTracker</code></a> when it is actually needed. If it is no longer needed destroy it by calling <a href="../Reference/JavaScript%20API/classes/ClientTracker.html#method_destroy"><code>AR.ClientTracker.destroy()</code></a>.</p>
<p>To view the sample you can use the image in <a href="targetimages.html">on this page</a></p>

<h2 id="solar-system-ir-">Solar System (IR)</h2>
<p>In this demo we combined vision based augmented reality capabilities with 3D models to visualize our solar system in an unique way. The example allows viewers to look at several planets of the solar system and receive basic information for each planet.</p>
<p><img src="images/demo_solar_ir_1.jpg" alt="Screenshot of the complete demo." title="Screenshot of the complete demo."></p>
<p>The augmentation consists of a backdrop that is used to darken the overlaid image and the planets of our solar system (still including Pluto). Each planet is loaded as a separate 3D model to allow it to be animated independently from each other.</p>
<p><img src="images/demo_solar_ir_jupiter.png" alt="3D model of the planet Jupiter." title="3D model of the planet Jupiter."></p>
<p>Looking at the code of the example there are a few components worth noting. The detail information for each planet is stored in the <code>planetsInfo</code> array which is then used to create the <a href="../Reference/JavaScript%20API/classes/Model.html"><code>AR.Model</code></a> object for each planet. Depending on the size and distance from the sun each planet is placed on the target using the <code>translate</code> and <code>scale</code> properties.</p>
<p>The backdrop is a simple <a href="../Reference/JavaScript%20API/classes/ImageDrawable.html"><code>AR.ImageDrawable</code></a> that is added together with the planets to the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a> drawables.</p>
<pre><code>var backdropImg = new AR.ImageResource(&quot;assets/backdrop.png&quot;);
    var backdrop = [new AR.ImageDrawable(backdropImg, 2)];
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/99_Demo_3_SolarSystem(2dTracking)/js/solarsystem2dtracking.js#L158-L159">GitHub</a>
</div>

<p>Animating the planets on a circle around the sun is accomplished by the utilizing multiple <a href="../Reference/JavaScript%20API/classes/PropertyAnimation.html"><code>AR.PropertyAnimation</code></a>s which are combined in <a href="../Reference/JavaScript%20API/classes/AnimationGroup.html"><code>AR.AnimationGroup</code></a>s. The function <code>createOrbitAnimation(planet, info)</code> creates the necessary animations for this action. The circle is divided in 4 quadrants which require different animations for the x and y axis. Animations for the x and y axis are combined in a parallel animation and are played sequentially  in order to achieve the desired circular movement.</p>
<p>Initially the planets are static and don&#39;t move. Once the user clicks the animate button the <code>toggleAnimatePlanets()</code> function is called. It checks the current state of the animations and starts, pauses, or resumes the animations accordingly.</p>
<p>Another part of the demo is the selection of planets and the displaying of a selected planet&#39;s information. Each planets <a href="../Reference/JavaScript%20API/classes/Model.html"><code>AR.Model</code></a> has an <code>onClick</code> trigger set which calls the <code>planetClicked()</code> function. This call displays a selected planet&#39;s information on the HUD. Helper functions <code>selectPlanet()</code> and <code>screenClicked()</code> activate and deactivate the selected animations and reset a previously selected planets <code>scale</code> property.</p>
<p><img src="images/solar_system.jpg" alt="Target image"></p>
<p>To view the sample you can use the image in <a href="targetimages.html">on this page</a></p>

<h2 id="solar-system-geo-">Solar System (Geo)</h2>
<p>Similar to the <a href="solarsystemir.html">Solar System (IR) demo</a> this demo displays the planets of our solar system, but positions them in the user&#39;s vicinity using a location based approach.</p>
<p><img src="images/demo_solar_geo_1.jpg" alt="Screenshot of the complete demo." title="Screenshot of the complete demo."></p>
<p>The detail information of each planet is defined in the <code>init()</code> function. Factors are defined to scale the planets to a reasonable size and all planets are combined in the <code>planetsInfo</code> array.</p>
<pre><code>/* put sun, planets (and pluto) in an array */
    this.planetsInfo = [sun, mercury, venus, earth, mars, jupiter, saturn, uranus, neptun, pluto];
</code></pre><div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/99_Demo_2_SolarSystem(Geo)/js/solarsystemgeo.js#L149-L150">GitHub</a>
</div>

<p>Planets are represented by an <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> that features the planets image and name indicated as drawables. The <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> of each planet is positioned using a <a href="../Reference/JavaScript%20API/classes/RelativeLocation.html"><code>AR.RelativeLocation</code></a> that allows to placement of objects relative to the user&#39;s location. Therefore it is possible to position the solar system in northerly direction regardless of the actual longitude and latitude of the user&#39;s current position.</p>
<p>An indicator is added to the suns <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a> so the user is continually guided to look in the &quot;right&quot; direction.</p>
<p>Animation of the planets is done similarly to the <a href="3dmodels.html">3D Model sample</a> where the circular movement is composed of multiple <a href="../Reference/JavaScript%20API/classes/PropertyAnimation.html"><code>AR.PropertyAnimation</code></a>s that are combined using <a href="../Reference/JavaScript%20API/classes/AnimationGroup.html"><code>AR.AnimationGroup</code></a>s. The <code>animate(planet)</code> function is responsible for creating these animations for a moving planet.</p>
<p>Again similar to the <a href="3dmodels.html">3D Model sample</a> the <code>planetClicked()</code> function, which is assigned to the <code>onClick</code> trigger, displays the planets information on the HUD.</p>

<h2 id="hardware-control">Hardware control</h2>
<p>The Hardware control example series will show how you can use the hardware API. The example is split into three different parts which illustrate the different features of the API, both native and Javascript. At the end of the series, you will have a complete overview of the API.</p>
<p>This sample consists of three parts</p>
<ol>
<li><a href="#frontcam">Front Camera</a></li>
<li><a href="#camswitch">Camera Switching</a></li>
<li><a href="#advanced">Advanced Features</a></li>
</ol>
<p><a id="frontcam"></a></p>
<h3 id="front-camera-1-3-">Front Camera (1/3)</h3>
<p>The first part of the series will present a set of POIs in the 8 compass directions using the front camera of the device, if available. The POIs are loaded from a local JSON file, using a different offset value for each POI to put them around the user in different directions.</p>
<p>The example <a href="retrievingpoidata.html#local">Retrieving POI Data</a> already explained how to load POI data from a local resource and display them in the augmented reality view.</p>
<p>This example shows how to initialize the <code>ARchitectView</code> using the front camera of the device.</p>
<p>The SDK can be configured to start with an active front camera using a <code>StartupConfiguration</code> as a parameter to the <code>onCreate()</code> method. An example implementation looks like the following:</p>
<pre><code class="lang-java">     @Override
    public void onCreate( final Bundle savedInstanceState ) {
        super.onCreate( savedInstanceState );

        final StartupConfiguration config = new StartupConfiguration(
            licenseKey,
            StartupConfiguration.Features.Geo,
            StartupConfiguration.CameraPosition.FRONT
        );

        this.architectView.onCreate( config );
    }
</code></pre>
<p>If the device has no front camera, the default system camera will be used. </p>
<p><a id="camswitch"></a></p>
<h3 id="camera-switching-2-3-">Camera Switching (2/3)</h3>
<p>The second part uses the same POIs, but starts the augmented reality view with the default configuration.</p>
<p>The user can then switch between front facing and rear camera by pressing the button &quot;Switch Camera&quot;. The button is defined in <strong>index.html</strong> and calls <code>World.switchCam()</code> on click: </p>
<pre><code class="lang-js">    /*
     * Switch between front and back camera
     */
    switchCam: function switchCamFn() {
        if (AR.hardware.camera.position == AR.CONST.CAMERA_POSITION.FRONT) {
            AR.hardware.camera.position = AR.CONST.CAMERA_POSITION.BACK
        } else {
            AR.hardware.camera.position = AR.CONST.CAMERA_POSITION.FRONT            
        }
    }
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/8_HardwareControl_2_CameraSwitching/js/camSwitch.js#L109-L118">GitHub</a>
</div>

<p>The <code>Marker</code> constructor function also sets the <code>mirrored</code> flag of the marker title and description. See <code>marker.js</code> for details about how this is implemented: the odd-numbered POIs have mirrored titles, and even-numbered POIs have mirrored descriptions.</p>
<p>This flag has no effect when viewing the AR scene through the rear camera. When using the front facing camera, all objects are mirrored like the camera image, except <a href="../Reference/JavaScript%20API/classes/Label.html"><code>Label</code></a> and <a href="../Reference/JavaScript%20API/classes/HTMLDrawable.html"><code>HTMLDrawable</code></a> object. By setting the <code>mirrored</code> flag you can override the default behaviour.</p>
<p><a id="advanced"></a></p>
<h3 id="advanced-features-3-3-">Advanced Features (3/3)</h3>
<p>The third example shows how to use the other functions of the hardware access API. </p>
<p>By pressing the button &quot;Camera Info&quot; the user can obtain information about which hardware feature are available on the device camera:</p>
<pre><code class="lang-js">    // display camera info panel
    showCamInfo: function showCamInfoFn() {
        // update panel values
        var features = AR.hardware.camera.features;

        $(&quot;#camera-focus-modes&quot;).html(features.focusModes.join());
        $(&quot;#camera-positions&quot;).html(features.positions.join());
        $(&quot;#camera-zoom-max&quot;).html(Math.round(features.zoomRange.max));

        // show panel
        $(&quot;#panel-caminfo&quot;).panel(&quot;open&quot;, 123);
    }
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/8_HardwareControl_3_AdvancedFeatures/js/hwFeatures.js#L124-L135">GitHub</a>
</div>

<p>When the user presses the button &quot;Camera Control&quot; another panel is shown, with more controls available to the user.</p>
<ul>
<li><strong>Zoom</strong> initially set to 1: the zoom factor ranges between 1 and a maximum value, which depends on the device capabilities.</li>
<li><strong>Autofocus</strong>: when checked, the continuous autofocus function of the camera is active. By disabling it, the camera locks the focus on the currently framed object.</li>
<li><strong>Flashlight</strong>: by checking this box, the user can turn the flashlight on and off.</li>
</ul>
<p>To use the camera zoom, you can read or change the value of <a href="../Reference/JavaScript%20API/classes/hardware.html#property_camera.zoom"><code>AR.hardware.camera.zoom</code></a>:</p>
<pre><code class="lang-js">    // updates values shown in &quot;control panel&quot;
    updateRangeValues: function updateRangeValuesFn() {

        // get current slider value (0..100);
        var slider_value = $(&quot;#panel-zoom-range&quot;).val();

        // zoom level (1 up to max available)
        var maxRangeValue = Math.round((AR.hardware.camera.features.zoomRange.max - 1) * (slider_value / 100) + 1);

        // update UI labels accordingly
        $(&quot;#panel-zoom-value&quot;).html(maxRangeValue);

        AR.hardware.camera.zoom = maxRangeValue;
    },
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/8_HardwareControl_3_AdvancedFeatures/js/hwFeatures.js#L137-L150">GitHub</a>
</div>

<p>The value of <a href="../Reference/JavaScript%20API/classes/hardware.html#property_camera.focusMode"><code>AR.hardware.camera.focusMode</code></a> represents the focusing mode of the camera and can be set to <code>AR.CONST.CAMERA_FOCUS_MODE.CONTINUOUS</code> or <code>AR.CONST.CAMERA_FOCUS_MODE.ONCE</code>.</p>
<p>Continuous mode is the default if the device supports it, in this mode the camera will try to refocus automatically when necessary.</p>
<p>By setting the focus mode to <code>ONCE</code> you can force the camera to refocus once on the current view. If you need to change focus you can set this value again. Each time the value <code>ONCE</code> is set, the camera tries to focus on the current scene again:</p>
<pre><code class="lang-js">    // updates values shown in &quot;control panel&quot;
    updateFocusMode: function updateFocusModeFn() {

        // get current checkbox status
        var check_value = $(&quot;#panel-focus-auto&quot;).is(&quot;:checked&quot;);

        if (check_value) {
            AR.hardware.camera.focusMode = AR.CONST.CAMERA_FOCUS_MODE.CONTINUOUS;
        } else {
            AR.hardware.camera.focusMode = AR.CONST.CAMERA_FOCUS_MODE.ONCE;
        }
    },
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/8_HardwareControl_3_AdvancedFeatures/js/hwFeatures.js#L152-L163">GitHub</a>
</div>

<p>To access the flashlight, you can read or change the value of <a href="../Reference/JavaScript%20API/classes/hardware.html#property_flashlight"><code>AR.hardware.camera.flashlight</code></a>:</p>
<pre><code class="lang-js">    // updates values shown in &quot;control panel&quot;
    updateFlashlight: function updateFlashlightFn() {

        // get current checkbox status
        var check_value = $(&quot;#panel-flashlight&quot;).is(&quot;:checked&quot;);
        AR.hardware.camera.flashlight = check_value;
    },
</code></pre>
<div class="githubnote">
view source code on <a target="_blank" href="https://github.com/Wikitude/wikitude-sdk-samples/blob/master/8_HardwareControl_3_AdvancedFeatures/js/hwFeatures.js#L165-L171">GitHub</a>
</div>

<h2 id="plugins-api">Plugins API</h2>
<p>This guide consists of multiple sections, first we discuss Wikitude SDK Plugins in general, than we talk about platform specifics and how to register a plugin with the Wikitude SDK and then we go through each of the sample plugins included with the Wikitude Example Applications.</p>
<ol>
<li><a href="#about">About Wikitude SDK Plugins</a></li>
<li><a href="#platformspecifics">Platform Specifics</a></li>
<li><a href="#registerplugin">Registering Plugins</a></li>
<li><a href="#barcode">QR &amp; Barcode Plugin</a></li>
<li><a href="#facedetection">Face Detection Plugin</a></li>
</ol>
<p><a id="about"></a></p>
<h3 id="about-wikitude-sdk-plugins">About Wikitude SDK Plugins</h3>
<p>Technically a plugin is a class, either written in C++ or Java, that is derived from the Wikitude Plugin base class. Beside lifecycle handling and options to enable and disable the plugin, the Plugin class has four main methods that you can override <code>cameraFrameAvailable</code> which is called each time the camera has a new frame, <code>update</code> which is called after each image recogntion cycle as well as &#39;startRender&#39; and &#39;endRender&#39; which are called before and after the Wikitude SDK does its rendering.</p>
<p>The most important thing to remember when working with plugins is that they need to have a unique identifier! If the attempt is made to register a plugin with an identifier that is already known to the Wikitude SDK, the register method call will return false.</p>
<h3 id="plugin-base-class">Plugin Base Class</h3>
<pre><code>class Plugin {
   public:
      Plugin(std::string identifier_);
      ~Plugin();
      string getIdentifier() const; // returns a unique plugin identifier
      bool processesColorCameraFrames(); // returns true if the plugins wants to process color frames instead of bw

      void setEnabled(bool enabled_);
      bool isEnabled();

      string callJavaScript(string javaScriptSnippet); // evaluates the given JavaScript snippet in the currently loaded ARchitect World context.

   protected:
      void initialize(); // called when the plugin is initially added to the Wikitude SDK
      void pause(); // called when the Wikitude SDK is paused e.g. the application state changes from active to background
      void resume(uint pausedTime_); // called when the Wikitude SDK resumes e.g. from background to active state. pausedTime represents the time in milliseconds that the plugin was not updated.
      void destroy(); // called when the plugin is removed from the Wikitude SDK

      void cameraFrameAvailable(const Frame&amp;; cameraFrame_); // called each time the camera has a new frame
      void update(const vector&lt;RecognizedTarget&gt; recognizedTargets_); // called each time the Wikitude SDK renders a new frame

      void startRender(); // called before any Wikitude SDK internal rendering is done
      void endRender(); // called right after any Wikitude SDK internal rendering is done

   protected:
      string      _identifier;
      bool        _enabled;
};
</code></pre><p>With those methods in place your plugin will be able to read the full camera image for your own purpose, where the YUV image is also processed in wikitude’s computer vision engine.</p>
<h3 id="information-about-recognized-targets">Information about Recognized Targets</h3>
<p>In case you have the wikitude SDK running with ongoing image recognition, the plugin API will populate the <code>RecognizedTarget</code> in the <code>update</code> method once an image has been recognized. The plugin can then work with class RecognizedTarget, which wraps the details of the target image in the camera view. With that you can read out the pose of the target image and use it for your purposes. Additionally the call contains the calculated distance to the recognized target</p>
<pre><code>class RecognizedTarget {
   public:
      const string&amp;    getIdentifier() const; // the identifier of the target. The identifier is defined when the target is added to a target collection
      const Mat4&amp;      getModelViewMatrix() const; // the model view matrix that defines the transformation of the target in the camera frame (translation, rotation, scale)
      const Mat4&amp;      getProjectionMatrix() const;
      const float      getDistanceToCamera() const; // represents the distance from the target to the camera in millimeter
};
</code></pre><p>Passing values from within the plugin to the JavaScript part of your augmented reality experience is done via the <code>addToJavaScriptQueue()</code> method of the Plugin class. Using this function will execute any JavaScript code in the context of your augmented reality experience.</p>
<p><a id="platformspecifics"></a></p>
<h3 id="platform-specifics">Platform Specifics</h3>
<p>To be able to use a C++ Wikitude plugin on Android, it is necessary to create a binary from the C++ code for each supported CPU architecture. To make this process as easy as possible we prepared an Android NDK make file and and some template code which passes your plugin to the Wikitude SDK. In the following section we discuss how you need to adapt these templates so they&#39;ll work for your plugin. </p>
<p>Please note that if you would like to use multiple C++ plugins in your app, you will need to package all plugins in one shared library. This is necessary because we use JNI to register C++ plugins with the Wikitude SDK and the symbol to do that has to be unique.</p>
<h3 id="android-c-wikitude-plugin-library-build">Android C++ Wikitude Plugin Library Build</h3>
<p>All files needed are located under the folder PluginBuilder in the Wikitude SDK Android package.
If you didn&#39;t setup the Android NDK yet, please follow the <a href="https://developer.android.com/intl/ja/ndk/guides/setup.html">official guide</a>.</p>
<p>Let&#39;s take a look at the Android.mk file, located under <code>SDKPackageRoot/PluginBuilder/jni</code>. The first thing we do is declare a variable containing the path to the source files relative to the make files location and set <code>LOCAL_PATH</code> to this location. We define where all include files are located and which files need to be compiled. Since our Example Plugin uses Android log we link android native log.</p>
<pre><code>LOCAL_PATH := $(call my-dir)/..
SRC_DIR := $(LOCAL_PATH)/src

include $(CLEAR_VARS)

LOCAL_PATH := $(SRC_DIR)
include $(CLEAR_VARS)

LOCAL_MODULE := samplePlugin

LOCAL_C_INCLUDES := $(SRC_DIR)
LOCAL_SRC_FILES := __YOUR_PLUGIN__.cpp JniRegistration.cpp Plugin.cpp

LOCAL_LDLIBS += -llog

include $(BUILD_SHARED_LIBRARY)
</code></pre><p>The PluginLoader/src folder contains various src files which are needed so your plugin will compile and link correctly. Please don&#39;t modify any of them except the <code>__YOUR_PLUGIN__.h</code> and <code>__YOUR_PLUGIN__.cpp</code>. One other file that needs some slight modifications is <code>JniRegistration.cpp</code> shown below. Adapt the include directive and the constructor call to your plugin name and if you would like to use multiple C++ plugins, feel free to add more plugins to the <code>cPluginsArray</code> array but adjust the <code>numberOfPlugins</code> count accordingly.</p>
<p>If you packaged multiple plugins in one shared library but would like to instantiate only a subset of those plugins you can pass an identifier to this method when loading the library from Java. You can then decide which plugins to create depending on the value of <code>jPluginName</code>.</p>
<pre><code>#include &lt;jni.h&gt;

#include &quot;Plugin.h&quot;
#include &quot;__YOUR_PLUGIN__.h&quot;

extern &quot;C&quot; JNIEXPORT jlongArray JNICALL Java_com_wikitude_architect_PluginManager_createNativePlugins(JNIEnv *env, jobject thisObj, jstring jPluginName) {

    int numberOfPlugins = 1;

    jlong cPluginsArray[numberOfPlugins];
    cPluginsArray[0] = (jlong) new __YOUR_PLUGIN__(&quot;com.example.plugin&quot;);

    jlongArray jPluginsArray = env-&gt;NewLongArray(numberOfPlugins);
    if (jPluginsArray != nullptr) {
        env-&gt;SetLongArrayRegion(jPluginsArray, 0, numberOfPlugins, cPluginsArray);
    }

    return jPluginsArray;
}
</code></pre><p>To build the plugin binary files, navigate to the jni folder and call ndk-build. A libs folder will be created containing libraries for arm7, arm64 and intel. Copy the contents of the libs folder to <code>YourProjectRoot/app/src/main/jniLibs</code>.</p>
<p><a id="registerplugin"></a></p>
<h3 id="registering-plugins">Registering Plugins</h3>
<p>On Android plugins can either be written in C++ or Java. The registration process between C++ and Java is a little different in the following sections we first show how to register a C++ plugin and then how to register a Java plugin.</p>
<h3 id="register-c-plugin">Register C++ Plugin</h3>
<p>To register a C++ plugin with the Wikitude SDK, call the <code>registerNativePlugins</code> method of the <code>ArchitectView</code> instance, passing the name of your plugin library. Do not add <code>lib</code> in front of the name or add the <code>.so</code> extension. Please make sure that the <code>onCreate</code> method of the <code>ArchitectView</code> was already called. </p>
<pre><code class="lang-java">@Override
protected void onPostCreate(final Bundle savedInstanceState) {
    super.onPostCreate(savedInstanceState);
    this.architectView.registerNativePlugins(&quot;pluginLibraryName&quot;);
}
</code></pre>
<p>If you packaged multiple plugins into your library and would like to decide at runtime which plugin(s) to load, you can pass an identifier on which you are able to react to in native code.</p>
<pre><code class="lang-java">@Override
protected void onPostCreate(final Bundle savedInstanceState) {
    super.onPostCreate(savedInstanceState);
    this.architectView.registerNativePlugins(&quot;pluginLibraryName&quot;, &quot;plugin_1&quot;);
}
</code></pre>
<h3 id="register-java-plugin">Register Java Plugin</h3>
<p>To register a Java plugin with the Wikitude SDK, call the <code>registerPlugin</code> method of the <code>ArchitectView</code> instance passing an instance of your Plugin.</p>
<pre><code class="lang-java">@Override
protected void onPostCreate(final Bundle savedInstanceState) {
    super.onPostCreate(savedInstanceState);
    this.architectView.registerPlugin(new MyPlugin());
}
</code></pre>
<p><a id="barcode"></a></p>
<h3 id="barcode-and-qr-code-reader">Barcode and QR code reader</h3>
<p>This samples shows a full implementation of the popular barcode library ZBar into the Wikitude SDK. As ZBar is licensed under LGPL2.1 this sample can also be used for other projects.</p>
<p>ZBar is an open source software suite for reading bar codes from various sources, such as video streams, image files and raw intensity sensors. It supports many popular symbologies (types of bar codes) including EAN-13/UPC-A, UPC-E, EAN-8, Code 128, Code 39, Interleaved 2 of 5 and QR Code.</p>
<p>First let&#39;s have a look at the <code>BarcodePlugin.h</code> file. To create the bar code plugin we derive our <code>BarcodePlugin</code> class from the <code>wikitude::sdk::Plugin</code> class and override <code>initialize</code>, <code>destroy</code>, <code>cameraFrameAvailable</code> and <code>update</code>. We also declare the following member variables: <code>_worldNeedsUpdate</code>, <code>_image</code> and <code>_imageScanner</code>. The <code>_worldNeedsUpdate</code> variable will later be used as an indicator if we need to update the <code>ArchitectView</code>, <code>_image</code> and <code>_imageScanner</code> are classes from <code>zBar</code> which we&#39;ll use to scan for bar codes.</p>
<pre><code class="lang-c++">class BarcodePlugin : public wikitude::sdk::Plugin {
public:
    BarcodePlugin(int cameraFrameWidth, int cameraFrameHeight);
    virtual ~BarcodePlugin();

    virtual void initialize();
    virtual void destroy();

    virtual void cameraFrameAvailable(const wikitude::sdk::Frame&amp; cameraFrame_);
    virtual void update(const std::list&lt;wikitude::sdk::RecognizedTarget&gt;&amp; recognizedTargets_);

protected:
    int                             _worldNeedsUpdate;

    zbar::Image                     _image;
    zbar::ImageScanner              _imageScanner;
};
</code></pre>
<p>We now go through each method of the <code>BarcodePlugin</code> class, starting with the constructor and destructor. In the constructor we set <code>_worldNeedsUpdate</code> to zero indicating that there is no update necessary and initialize the <code>zBar::Image</code> member variable passing its constructor the width and height of the camera frame, the image format of <code>Y800</code>, set its data pointer to null and the data length to zero. Since we didn&#39;t allocate any data dynamically, there is nothing to do in the destructor.</p>
<pre><code class="lang-c++">BarcodePlugin::BarcodePlugin(int cameraFrameWidth, int cameraFrameHeight) :
Plugin(&quot;com.wikitude.ios.barcodePluign&quot;),
_worldNeedsUpdate(0),
_image(cameraFrameWidth, cameraFrameHeight, &quot;Y800&quot;, nullptr, 0)
{
}

BarcodePlugin::~BarcodePlugin()
{
}
</code></pre>
<p>In the <code>initialize</code> method we configure the <code>zbar::ImageScanner</code> by calling <code>setConfig</code>, enabling all supported bar codes. If you are only interested in one or some particular types of bar codes, first disabling all bar code types and manually enabling each particular type would be the better idea. That way performance could be greatly improved.</p>
<pre><code class="lang-c++">void BarcodePlugin::initialize() {    
    _imageScanner.set_config(zbar::ZBAR_NONE, zbar::ZBAR_CFG_ENABLE, 1);
}
</code></pre>
<p>We react to the <code>destroy</code> event by setting the current data pointer of the <code>zbar::Image</code> member to null and length to zero.</p>
<pre><code class="lang-c++">void BarcodePlugin::destroy() {
    _image.set_data(nullptr, 0);
}
</code></pre>
<p>The last but most interesting methods are <code>cameraFrameAvailable</code> and <code>update</code>. In the <code>cameraFrameAvailable</code> method we set the data of our previously initialized <code>zbar::Image</code> member variable to the frame data we just received and the length of the data to frame width * frame height by calling <code>set_data</code>. We then start the scanning process by calling the <code>scan</code> method of our <code>zBar::ImageScanner</code> passing the <code>zBar::Image</code> member instance. The <code>zBar::ImageScanner::scan</code> method returns the number of detected bar codes in the image frame, we save this number in a local variable <code>n</code>. If <code>n</code> is not equal to the result of the last frame, which we saved to <code>_worldNeedsUpdate</code> member variable, we know there was a new bar code detected (meaning there was no bar code in the last frame) or that there was a bar code in the last frame and now there isn&#39;t. When that&#39;s the case, we do another check if there really was a bar code detected this frame and if there was we create a javascript code fragment which we pass to the <code>addToJavaScriptQueue</code> method from the <code>sdk::Plugin</code> base class. The javascript fragment contains code to set the html contents of the <code>loadingMessage</code> div element which is placed in the top of the view. We use the <code>zbar::Image::SymbolIterator</code> to get the first detected symbol and retrieve its data. That means even if there were multiple bar codes detected in the last frame we only use the first detected.</p>
<p>Since we aren&#39;t interested in the results of the Wikitude SDK image recognition and aren&#39;t rendering anything with OpenGL in this example we implement the <code>update</code> method empty.</p>
<pre><code class="lang-c++">void BarcodePlugin::cameraFrameAvailable(const wikitude::sdk::Frame&amp; cameraFrame_) {
    int frameWidth = cameraFrame_.getSize().width;
    int frameHeight = cameraFrame_.getSize().height;

    _image.set_data(cameraFrame_.getLuminanceData(), frameWidth * frameHeight);

    int n = _imageScanner.scan(_image);

    if ( n != _worldNeedsUpdate ) {
        if ( n ) {
            std::ostringstream javaScript;
            javaScript &lt;&lt; &quot;document.getElementById(&#39;loadingMessage&#39;).innerHTML = &#39;Code Content: &quot;;

            zbar::Image::SymbolIterator symbol = _image.symbol_begin();
            javaScript &lt;&lt; symbol-&gt;get_data();

            javaScript &lt;&lt; &quot;&#39;;&quot;;

            addToJavaScriptQueue(javaScript.str());

        }
    }

    _worldNeedsUpdate = n;
}

void BarcodePlugin::update(const std::list&lt;wikitude::sdk::RecognizedTarget&gt;&amp; recognizedTargets_) {
}
</code></pre>
<p><a id="facedetection"></a></p>
<h3 id="face-detection">Face Detection</h3>
<p>This samples shows how to add face detection to your Wikitude augmented reality experience using OpenCV.</p>
<p>The Face Detection Plugin Example consists of the C++ classes <code>FaceDetectionPlugin</code> and <code>FaceDetectionPluginConnector</code> as well as the Java class <code>FaceDetectionPluginActivity</code>. We will use OpenCV to detect faces in the current camera frame and OpenGL calls in Java to render a rectangle around detected faces. </p>
<p>The <code>FaceDetectionPluginConnector</code> acts as our interface between native code and Java and contains some JNI code, since JNI is not the focus of this example we won&#39;t go into detail about the implementation. If you would like to have a look at the complete code feel free to browse the source code in the Wikitude SDK release package.</p>
<p>We implement two Java native methods <code>initNative</code> and <code>setFlipFlag</code>. First will be used to initialize the plugin with the path to an OpenCV database, second will be used to notify the Plugin about orientation changes of the device. The other methods <code>faceDetected</code>, <code>faceLost</code>, <code>projectionMatrixChanged</code> and <code>renderDetectedFaceAugmentation</code> will be called by the Plugin to update the Java Android Activity, which controls the rendering. </p>
<pre><code class="lang-c++">extern &quot;C&quot; JNIEXPORT void JNICALL
Java_com_wikitude_samples_FaceDetectionPluginActivity_initNative(JNIEnv* env, jobject obj, jstring databasePath_)
{
    ...
}

extern &quot;C&quot; JNIEXPORT void JNICALL
Java_com_wikitude_samples_FaceDetectionPluginActivity_setFlipFlag(JNIEnv* env, jobject obj, jint flag)
{
    ...
}

... ctor / dtor ...

void FaceDetectionPluginConnector::faceDetected(const float *modelViewMatrix)
{
...
}

void FaceDetectionPluginConnector::faceLost()
{
...
}

void FaceDetectionPluginConnector::projectionMatrixChanged(const float *projectionMatrix)
{
...
}

void FaceDetectionPluginConnector::renderDetectedFaceAugmentation() {
...
}
</code></pre>
<p>Next let&#39;s have a look at the <code>FaceDetectionPlugin</code> class. Again we we will leave out implementation details and focus on how we use the plugin itself. In the <code>cameraFrameAvailable</code> method we use OpenCV to detect faces in the current camera frame which the Wikitude SDK passes to the plugin. We call the observer which is an instance of the <code>FaceDetectionPluginConnector</code> to notify the Java activity about the result. The plugin base class defines <code>startRender</code> and <code>endRender</code>, depending on if you would like to render on top of or below of all rendering the Wikitude SDK does, you choose one of them or both to override. To render below all Wikitude rendering we choose <code>startRender</code> and again call the <code>FaceDetectionPluginConnector</code> instance which in turn calls the Android activity. Since we do not react on the result of the Wikitude SDK image recognition we leave <code>update</code> blank. </p>
<pre><code class="lang-c++">
... ctor/dtor ...

void FaceDetectionPlugin::cameraFrameAvailable(const wikitude::sdk::Frame&amp; cameraFrame_) {

    ... Control Open CV ...

    if ( _result.size() ) {
        convertFaceRectToModelViewMatrix(croppedImg, _result.at(0));
        _observer-&gt;faceDetected(_modelViewMatrix);
    } else {
        _observer-&gt;faceLost();
    }
}

void FaceDetectionPlugin::startRender() {
    _observer-&gt;renderDetectedFaceAugmentation();
}

void FaceDetectionPlugin::update(const std::list&lt;wikitude::sdk::RecognizedTarget&gt; &amp;recognizedTargets_) {
}

... other internally used methods ...
</code></pre>
<p>In the <code>FaceDetectionPluginActivity</code> Java class we override <code>onPostCreate</code> and initialize the Plugin by calling the <code>initNative</code> native method, passing the path to the database file. We also override <code>onConfigurationChanged</code> to get notify about device orientation changes and again notify the Plugin about it by calling the <code>setFlipFlag</code> native method. To render a rectangle around detected faces we created a class called <code>StrokedRectangle</code> which contains OpenGL calls. When the plugin detects, looses or recalculated the projection matrix it will call the appropriate Java methods which we use to update the <code>StrokedRectangle</code> instance. If the Plugin decides to render a rectangle around a detected face it will call <code>renderDetectedFaceAugmentation</code>. Since the plugin will only call this method in the <code>startRender</code> method, we know the current thread is the OpenGL thread and are able to dispatch OpenGL calls.</p>
<pre><code class="lang-java">
... imports ...

public class FaceDetectionPluginActivity extends SampleCamActivity {

    private File _cascadeFile;
    private StrokedRectangle rectangle = new StrokedRectangle(StrokedRectangle.Type.FACE);

    @Override
    protected void onPostCreate(final Bundle savedInstanceState) {
        ...
        initNative(_cascadeFile.getAbsolutePath());
        ...
    }

    private void setInterfaceOrientationInPlugin() {
        ...
        setFlipFlag(...);
        ...
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        setInterfaceOrientationInPlugin();
    }

    public void onFaceDetected(float[] modelViewMatrix) {
        rectangle.setViewMatrix(modelViewMatrix);
    }

    public void onFaceLost() {
       rectangle.onFaceLost();
    }

    public void onProjectionMatrixChanged(float[] projectionMatrix) {
        rectangle.setProjectionMatrix(projectionMatrix);
    }

    public void renderDetectedFaceAugmentation() {
        rectangle.onDrawFrame();
    }

    private native void initNative(String casecadeFilePath);
    private native void setFlipFlag(int flag);

}
</code></pre>
<p>If you are interested in the implementation details of the <code>FaceDetectionPluginActivity</code> or the <code>StrokedRectangle</code> class, you can find both classes in our Wikitude SDK Example Application. </p>

<h2 id="target-images">Target Images</h2>
<h3 id="all-samples">All samples</h3>
<p><a href='images/wikitude_sample_app_target_images.zip'>Click here to download all target images</a></p>
<p><img class="jslghtbx-thmb" src="images/magazine_page_one.jpeg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='clientrecognition.html'>Client Recognition</a>">
<img class="jslghtbx-thmb" src="images/magazine_page_two.jpeg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='clientrecognition.html'>Client Recognition</a>">
<img class="jslghtbx-thmb" src="images/Stone_Wall.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='clientrecognition.html'>Client Extended Recognition</a>">
<img class="jslghtbx-thmb" src="images/schloss_johannisberg.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='cloudrecognition.html'>Cloud Recognition</a>">
<img class="jslghtbx-thmb" src="images/brazil.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='cloudrecognition.html'>Cloud Recognition</a>">
<img class="jslghtbx-thmb" src="images/barone.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='cloudrecognition.html'>Cloud Recognition</a>">
<img class="jslghtbx-thmb" src="images/etiquette_ermitage.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='cloudrecognition.html'>Cloud Recognition</a>">
<img class="jslghtbx-thmb" src="images/gw_bf2011.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='cloudrecognition.html'>Cloud Recognition</a>">
<img class="jslghtbx-thmb" src="images/carAd.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='3dmodels.html'>3D models</a>">
<img class="jslghtbx-thmb" src="images/solar_system.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='solarsystemir.html'>Solar System (IR)</a>">
<img class="jslghtbx-thmb" src="images/ir_geo_poster.jpg" data-jslghtbx data-jslghtbx-group="group1" data-jslghtbx-caption="Sample: <a href='2dtrackingandgeo.html#combine-client-recognition-and-pois'>Combine Client Recognition and POIs</a>">
<img class="jslghtbx-thmb" src="images/barcode_wikitude.png" data-jslghtbx data-jslghtbx-group="group2" data-jslghtbx-caption="Sample: <a href='pluginsapi.html'>Plugins API barcode reader</a>">
<img class="jslghtbx-thmb" src="images/hello_wikitude_qr.png" data-jslghtbx data-jslghtbx-group="group2" data-jslghtbx-caption="Sample: <a href='pluginsapi.html'>Plugins API QR reader</a>"></p>

<h1 id="wikitude-cloud-recognition">Wikitude Cloud Recognition</h1>
<p class='intro' markdown='1'>The Wikitude Cloud Recognition service is a cloud-based service provided by Wikitude, which recognizes images sent from Android and iOS apps using the Wikitude SDK. The recognized images are then tracked in the live camera feed and can be used for augmented reality experiences.</p>

<p>This documentation focuses on the RESTful API called Manager API, which is used to interact on a backend level with the Cloud Recognition service.</p>
<h2 id="general-definitions">General Definitions</h2>
<ul>
<li><p><strong>Target</strong>: An image and its associated extracted data that is used to recognize an image.</p>
</li>
<li><p><strong>Target Collection</strong>: A group of <code>targets</code> that are searched together. Think of it as a directory, which contains all your images you want to search. The Wikitude SDK can work with two different sorts of <code>TargetCollections</code></p>
<ul>
<li>On-device Target Collection: a static <code>wtc</code> file containing the extracted data of your images. Can consist of up to 1,000 images.</li>
<li>Cloud Target Collection: A target collection stored on the Wikitude server. See <code>Cloud Archive</code> below. </li>
<li></li>
</ul>
</li>
<li><strong>Cloud Archive</strong>: An archive stored on the server that is optimized for cloud-based recognition. It is generated from a <code>TargetCollection</code> and is used in combination with the Wikitude SDK <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>.</li>
</ul>
<p><strong>Manager API</strong>: A RESTful web API allowing developers to interact with the Cloud Recognition server for managing <code>Targets</code>, <code>TargetCollections</code> and <code>Cloud Archives</code>. Only you as a developer uses this API. None of your users of your app will interact with this API.</p>
<p><strong>Client API</strong>: The Client API is the interface between the Wikitude SDK and the Cloud Recognition Service. The API itself is encapsulated in the Wikitude SDK class <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a> and not directly accessible. Calls on the client API are called <code>Scans</code>. </p>
<p><strong>Region</strong>: Wikitude is providing several hosting locations for its Cloud Recognition services to cut down unwanted network latency. As a developer you need to choose on which <code>Region</code> you and your customers want to operate. </p>
<h2 id="getting-started-with-the-cloud-recognition-service">Getting Started with the Cloud Recognition Service</h2>
<h3 id="regional-availability-of-wikitude-cloud-recognition-service">Regional availability of Wikitude Cloud Recognition Service</h3>
<p>As as a developer using Wikitude Cloud Recognition Service you need to choose which server location you want to use for your projects. Wikitude operates several servers running Wikitude Cloud Recognition Service in different locations world-wide.</p>
<p>As the region servers are separated content which is stored on one region servers is only available on this particular server. <strong>Content is not synced across regions</strong>. You can choose from the following <code>Regions</code></p>
<ul>
<li><code>Americas</code></li>
<li><code>China</code></li>
<li><code>Europe</code></li>
</ul>
<p>The servers for each region have separate dedicated domain names and therefore different configurations. </p>
<p><a id="targetmanagerregional"></a></p>
<table>
<thead>
<tr>
<th style="text-align:left">Region</th>
<th style="text-align:center">Target Manager</th>
<th>Manager API</th>
<th>SDK Setting</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Americas</td>
<td style="text-align:center"><a href="https://targetmanager.wikitude.com">targetmanager.wikitude.com</a></td>
<td><a href="https://api-us.wikitude.com">https://api-us.wikitude.com</a></td>
<td><code>Americas</code></td>
</tr>
<tr>
<td style="text-align:left">China</td>
<td style="text-align:center"><a href="https://targetmanager-cn.wikitude.com">targetmanager-cn.wikitude.com</a></td>
<td><a href="https://api-cn.wikitude.com">https://api-cn.wikitude.com</a></td>
<td><code>China</code></td>
</tr>
<tr>
<td style="text-align:left">Europe</td>
<td style="text-align:center"><a href="https://targetmanager.wikitude.com">targetmanager.wikitude.com</a></td>
<td><a href="https://api.wikitude.com">https://api.wikitude.com</a> or <a href="https://api-eu.wikitude.com">https://api-eu.wikitude.com</a></td>
<td><code>Europe</code></td>
</tr>
</tbody>
</table>
<h3 id="preparation">Preparation</h3>
<ol>
<li><a href="http://www.wikitude.com/c/portal/login?p_l_id=533165">Create a free</a> Wikitude developer account or <a href="http://www.wikitude.com/c/portal/login?p_l_id=533165">log-in</a> if you are a returning developer</li>
<li>Get the <a href="http://www.wikitude.com/developer/licenses">API tokens</a> for the Manager API and the Client API to start your project. <a href="#authentication">Read more on authentication</a></li>
<li>Test the API for free using Wikitude&#39;s <a href="https://github.com/Wikitude/wikitude-cloud-recognition-api-samples">sample integrations</a></li>
<li>Once you finished your integration, <a href="https://www.wikitude.com/products/wikitude-cloud-recognition/">purchase</a> a commercial token.</li>
</ol>
<h3 id="first-steps-and-general-usage">First Steps and General Usage</h3>
<ol>
<li>Get familiar with the Manager API calls in the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html">API Reference</a>. </li>
<li>Create a first Target Collection using the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-TargetCollection-CreateTargetCollection"><code>Create Target Collection</code></a> endpoint and note down the ID of the Target Collection    </li>
<li>Create targets using the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-Target-CreateTarget"><code>Create Target</code></a> endpoint for that particular Target Collection</li>
<li>Important: <a href="index.html#api-TargetCollection-GenerateCloudArchive"><code>Generate a Cloud Archive</code></a> for your Target Collection</li>
<li>Go to the Wikitude SDK and create an Android or iOS project</li>
<li>Use the Client API token to authenticate your Android or iOS project</li>
<li>Use your Target Collection ID to recognize images</li>
</ol>
<p>For more information on the available endpoints and how to work with the Manager API see the <a href="cloudrecognitionworkflow.html">workflow section</a>.</p>
<p>Instead of creating a <code>TargetCollection</code>, adding one or more <code>Targets</code>, and generating a <code>Cloud Archive</code> by calling the REST API, the <a href="#targetmanagerregional">Wikitude Targetmanager</a> can be used to perform these steps (1-4) in the browser alternatively.</p>
<p>In case you would like to immediately test the API calls we recommend the tool <a href="https://www.getpostman.com/">Postman</a>. It helps you to quickly construct the requests and analyze the responses.</p>
<h2 id="authentication">Authentication</h2>
<p>The Cloud Recognition Service knows two authentication tokens, that you need in order to work with the service</p>
<ul>
<li><p><strong>Manager API token</strong> You need this token to authenticate yourself against the RESTful Manager API. The Manager API is used to create, add and delete targets and target collections. The token identifies your developer account. Calls to the Manager API do not count towards your quota limits.</p>
</li>
<li><p><strong>Client API token</strong> You need this token to authenticate calls from the Wikitude SDK to the Cloud Recognition services. It again authenticates calls as legitimate. The token is bound to your developer account. Calls from the Wikitude SDK to the service with a wrong or missing token can not access your target collections. </p>
</li>
</ul>
<h3 id="authentication-on-the-manager-api">Authentication on the Manager API</h3>
<p>The <strong>Manager API token</strong> must be added to each call towards the Wikitude Cloud Recognition Manager API. The token authenticates the user account that is using the API. </p>
<h3 id="authentication-on-the-client-api">Authentication on the Client API</h3>
<p>The <strong>Client API token</strong> must be added to your app project using the Wikitude SDK. This token is needed additionally beside the SDK license key when working with the <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a> class.</p>
<h2 id="quota-and-limits">Quota and Limits</h2>
<h3 id="general-upload-limit">General Upload Limit</h3>
<p>The Wikitude Cloud Recognition <strong>will not accept images bigger than 1024kB</strong> (1 MB). Trying to upload images exceeding this file size will result in a HTTP status code <code>400</code> together with an error message <code>FILE_SIZE_LIMIT_EXCEED</code>.</p>
<h3 id="limits-for-the-wikitude-cloud-recognition-service">Limits for the Wikitude Cloud Recognition Service</h3>
<p>There are two main limitations for the Wikitude Cloud Recognition service that you need to be aware of:</p>
<ul>
<li><p><strong>Targets</strong> Your token has a certain number of targets that you can upload and store on the cloud service under your developer account. The limit is always counted for your entire developer account and not for a single target collection. The service is not counting single uploads, but how many targets are currently stored in target collections under your account. </p>
</li>
<li><p><strong>Scans</strong> Scans are in effect calls from the Wikitude SDK via the Client API to the Cloud Recognition servers. All commercial license come with an allowance of 1,000,000 scans per month per developer account. <strong>Note:</strong> When using Continuous Search mode multiple calls are made to the server.</p>
</li>
</ul>
<h3 id="maximum-number-of-targets-in-a-target-collection">Maximum Number of Targets in a Target Collection</h3>
<p>A target collection can&#39;t exceed 50,000 targets.</p>
<h3 id="free-trial-license-for-cloud-recognition">Free Trial License for Cloud Recognition</h3>
<p>Wikitude provides a trial token for each developer account to try out the Cloud Recognition for free. This trial token has set a quota limit that allows developers to try and test the functionality of the service. Limitations for trial accounts</p>
<ul>
<li>Targets: 50,000</li>
<li>Scans: 1,000 per month</li>
</ul>
<p>To get your trial token for the REST, please visit the <a href="http://www.wikitude.com/developer/licenses">License page</a>. The trial token is directly integrated into the Target Manager Frontend.</p>
<h3 id="commercial-licenses">Commercial Licenses</h3>
<p>For production systems, we offer commercial licenses with various quota limits for <a href="http://www.wikitude.com/products/wikitude-cloud-recognition/">purchase</a>.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Product</th>
<th style="text-align:center">Targets</th>
<th>Scans</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cloud Recognition 1000</td>
<td style="text-align:center">1,000</td>
<td>1,000,000</td>
</tr>
<tr>
<td style="text-align:left">Cloud Recognition 10000</td>
<td style="text-align:center">10,000</td>
<td>1,000,000</td>
</tr>
<tr>
<td style="text-align:left">Cloud Recognition 25000</td>
<td style="text-align:center">25,000</td>
<td>1,000,000</td>
</tr>
<tr>
<td style="text-align:left">Cloud Recognition 50000</td>
<td style="text-align:center">50,000</td>
<td>1,000,000</td>
</tr>
<tr>
<td style="text-align:left">Cloud Recognition 100000 (*)</td>
<td style="text-align:center">100,000</td>
<td>1,000,000</td>
</tr>
</tbody>
</table>
<p>(*) Maximum number of targets per target collection can&#39;t exceed 50,000</p>

<h2 id="your-first-target-collections">Your first Target Collections</h2>
<p>Target Collections are central to working with Cloud Recognition service. They keep all your target images and are the base for the cloud archive.</p>
<p>Think of TargetCollection as a directory, where your images are stored. A TargetCollection forms a logical group, which is searched as a whole. Of course you can have several TargetCollections in your account, each consisting up to 50,000 images each. </p>
<h3 id="what-is-the-difference-between-cloud-archive-and-target-collection">What is the difference between Cloud Archive and Target Collection</h3>
<div class="warning">A Cloud Archive is an optimized version of your Target Collection for cloud-based recognition. Cloud Archives are in internal structure, that keeps all necessary data for performing image recognition on the server. </div>

<h3 id="structure-of-a-targetcollection">Structure of a TargetCollection</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Property</th>
<th style="text-align:left">Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>id</strong></td>
<td style="text-align:left">(String)</td>
<td>An ID that uniquely identifies the TargetCollection</td>
</tr>
<tr>
<td style="text-align:left"><strong>name</strong></td>
<td style="text-align:left">(String)</td>
<td>The Name of the TargetCollection, as defined by the user</td>
</tr>
<tr>
<td style="text-align:left"><strong>creDat</strong></td>
<td style="text-align:left">(Number)</td>
<td>A timestamp when the TargetCollection was created (as returned by JavaScript&#39;s <code>Date.now()</code> function)</td>
</tr>
<tr>
<td style="text-align:left"><strong>modDat</strong></td>
<td style="text-align:left">(Number)</td>
<td>A timestamp when the TargetCollection was last modified (as returned by JavaScript&#39;s <code>Date.now()</code> function)</td>
</tr>
</tbody>
</table>
<h3 id="create-a-target-collection">Create a Target Collection</h3>
<p>Creating a Target Collection is easy and can be done without any prerequisites in your account. In general it is your starting point and most likely your very first action.</p>
<p>Call the endpoint (using the domain of one of the <a href="gettingstartedcloudrecognition.html#targetmanagerregional">regional servers</a>)</p>
<pre><code>/cloudrecognition/targetCollection
</code></pre><p>with the mandatory <code>name</code> field as a <code>POST</code> request and you will create a new TargetCollection. The response will contain a TargetCollection object, where the ID is most important parameter. You can also add <code>metadata</code> to a TargetCollection in case you want to some additional descriptive information. The next step is to add images to your TargetCollection, so they can be recognized.</p>
<h2 id="add-target-images">Add Target Images</h2>
<p>A Target is an plain image that can be recognized by the Wikitude Cloud Recognition service. Adding or creating a target means to provide a URL to your image to the server, which then downloads the image, analyzes it  and adds it to the TargetCollection. To add an image call the endpoint</p>
<pre><code>/cloudrecognition/targetCollection/:tcId/target
</code></pre><p>with the <code>ID</code> of the TargetCollection, where you want to add the image. You need to add the a field <code>imageUrl</code> to your request. The image must be publicly accessible. 
Pay attention to the optional fields <code>name</code> and <code>metadata</code>. <code>name</code> is a unique identifier for your target within the TargetCollection. It is up to you to set and use this. The same is true for the <code>metadata</code> object, which takes a full JSON object and can be filled with any value you like. The <code>metadata</code> object will be present in the recognition response. </p>
<div class="tip"><strong>Important: </strong>You are not done yet. As a next step you need to Generate the Cloud Archive of your TargetCollection.</div>

<h3 id="structure-of-a-target">Structure of a Target</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Property</th>
<th style="text-align:left">Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">(String)</td>
<td>An ID that uniquely identifies the Target</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">(String)</td>
<td>The Name of the Target, as defined by the user</td>
</tr>
<tr>
<td style="text-align:left">imageUrl</td>
<td style="text-align:left">(String)</td>
<td>The URL pointing to the original, uncompressed and uncropped Target binary file</td>
</tr>
<tr>
<td style="text-align:left">thumbnailUrl</td>
<td style="text-align:left">(String)</td>
<td>The URL pointing to a thumbnail representation of the Target</td>
</tr>
<tr>
<td style="text-align:left">rating</td>
<td style="text-align:left">(Number)</td>
<td>The rating (from 0 to 3) of the Target</td>
</tr>
<tr>
<td style="text-align:left">fileSize</td>
<td style="text-align:left">(Number)</td>
<td>The file size of the original Target binary image file, in bytes</td>
</tr>
<tr>
<td style="text-align:left">physicalHeight</td>
<td style="text-align:left">(Number)</td>
<td>The physical (real world) height of the target, in millimeters</td>
</tr>
<tr>
<td style="text-align:left">creDat</td>
<td style="text-align:left">(Number)</td>
<td>A timestamp when the Target was created (as returned by JavaScript&#39;s Date.now() function)</td>
</tr>
<tr>
<td style="text-align:left">modDat</td>
<td style="text-align:left">(Number)</td>
<td>A timestamp when the Target was last modified (as returned by JavaScript&#39;s Date.now() function)</td>
</tr>
<tr>
<td style="text-align:left">metadata</td>
<td style="text-align:left">(JSON)</td>
<td>Arbitrary JSON data that is stored together with the target.</td>
</tr>
</tbody>
</table>
<h2 id="generate-a-cloud-archive">Generate a Cloud Archive</h2>
<p>Once you are done with adding targets you need to tell the server that it should generate your TargetCollection into a Cloud Archive. Call</p>
<pre><code>/cloudrecognition/targetCollection/:tcId/generation
</code></pre><p>again with the <code>ID</code> of your TargetCollection and the process will be started. Since this call is asynchronous you will receive the response immediately with a path in the Location-property in the header of the response. By calling the url with the path, for example</p>
<pre><code>/cloudrecognition/targetCollection/:tcId/generation/wtc/:generationId
</code></pre><p>with a GET-method request, you will see the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-TargetCollection-GetGenerationInformation">status of the progress</a> of the cloud archive generation in the response body as a JSON object. When the generation is completed, the cloud archive is available for recognition. Note that the generation process can take a while when generating a large TargetCollection for the first time. Small additions to existing cloud archives are processed a lot faster.</p>
<div class="warning"> Everytime you changed a target (add/delete) you need to manually call Generate Cloud Archive for your target collection. Otherwise 
<ul><li>your newly added image will not be recognized </li>
<li>your deleted image will still be recognized</li></ul></div>

<p>Your Cloud Archive is now ready on the server and can be used in combination with the Wikitude SDK from your app. See the SDK sample called <a href="cloudrecognition.html">Cloud Recognition</a> for more details. </p>
<h2 id="generate-a-wtc-file">Generate a WTC file</h2>
<p>You can create and download a wtc file of a specific Target Collection (<a href="../Reference/Cloud%20Recognition%20REST%20API/#api-TargetCollection-GenerateWTC">Generate WTC</a>) with up to 1000 targets by calling</p>
<pre><code>/cloudrecognition/targetCollection/:tcId/generation/wtc
</code></pre><p>with method POST. You have to specify the SDK version the wtc file should be built for in the request body. Valid values for the version are &quot;3.x&quot;, &quot;4.0&quot;, &quot;4.1&quot;, and &quot;5.0&quot;. Optionally, an email address can be added. The email is used for a notification once the generation of the wtc file has finished. Example for the request body:</p>
<pre><code>{
    &quot;sdkVersion&quot;: &quot;5.0&quot;,
    &quot;iwantmywtcfile@wikitude-user.com&quot;
}
</code></pre><p>Similar to the cloud archive generation this call is asynchronous, so the response header (Location) contains a path useful for requesting the <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-TargetCollection-GetWTCGenerationInformation">status of the wtc creation</a>. Once the status is <code>COMPLETED</code> the link to the actual wtc file can be requested from the <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-TargetCollection-GetTargetCollection">TargetCollection</a>. The received <code>TargetCollection</code> object (in the body of the response) contains an additional property called <code>wtc</code>, which is an array of wtc objects. Those objects consists of the following properties:</p>
<ul>
<li>the <code>url</code> to the wtc file, </li>
<li>the number of targets (<code>nrOfTargets</code>),</li>
<li>the <code>version</code>,</li>
<li>the creation date (<code>creDat</code>)</li>
</ul>
<h2 id="additional-calls">Additional calls</h2>
<p>Beside the above described steps the Manager API also offers to <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-TargetCollection-DeleteTargetCollection">Delete TargetCollections</a> and <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html#api-Target-DeleteTarget">Delete Targets</a>. </p>
<p>Using <code>GET</code> request you can query details about a <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-TargetCollection-GetTargetCollection">single TargetCollection</a>, <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-TargetCollection-GetAllTargetCollections">all Target Collections</a> in your account, a <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-Target-GetTarget">single Target</a> and <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-Target-GetAllTargets">all Targets within a TargetCollection</a>.</p>
<p>The physical height and the metadata of an existing target can be <a href="../Reference/Cloud%20Recognition%20REST%20API/#api-Target-UpdateTarget">updated</a>.</p>

<h1 id="development-workflow">Development Workflow</h1>
<p>The following section describes a default development workflow for writing AR content using the ARchitect JavaScript API. It demonstrates the code test and debug cycle and provides useful tips for each step.</p>
<h2 id="code-test-debug">Code, Test, Debug</h2>
<ol>
<li>Write your HTML, JavaScript and CSS using the text editor of your choice</li>
<li>Test in your desktop browser</li>
<li>Debug in your desktop browser using e.g. WebInspector</li>
<li>Test on a physical device</li>
<li>Debug on a physical device</li>
<li>Rinse and repeat</li>
</ol>
<p>You can use any editor for writing the ARchitect World. We particularly like <a href="http://www.sublimetext.com/">Sublime</a>, which has a great selection of plugins for web developers.</p>
<p>The next step is to test it out in a desktop browser. To have the ARchitect JavaScript API available in the desktop browser you&#39;ll need to include the ARchitect Desktop Engine (ADE). See the chapter <a href="ade.html">ARchitect Desktop Engine</a> for instructions on how to use it. While this is limited in visualizing the experience, it greatly helps in finding errors in the JavaScript code and reduces the time it takes to see effects of changes you have made to the HTML and CSS parts. Desktop browsers come with great debugging tools (e.g. <a href="https://developers.google.com/chrome-developer-tools/">Chrome&#39;s DevTools</a> ) that allow you to easily debug your JavaScript code and that you should make full use of when debugging ARchitect Worlds.</p>
<p>Once you have verified the JavaScript is working properly you should test it on the device of your choice. Either start your application that loads the ARchitect World or run it inside the Wikitude World Browser app.</p>
<h3 id="run-the-architect-world-within-the-wikitude-world-browser-on-android">Run the ARchitect World within the Wikitude World Browser on Android</h3>
<p>AR experiences can be tested on Android using the <a href="https://play.google.com/store/apps/details?id=com.wikitude" target="_top">Wikitude World Browser for Android</a>. Download the Wikitude app from Google Play. Launch the application and press the menu button in the upper left corner of the screen.</p>
<p><img src="images/WT8_Android_OpenMenu.png" alt=" "></p>
<p>Then tap the <code>Developer</code> button to open the developer login page.</p>
<p><img src="images/WT8_Android_DeveloperMenu.png" alt=" "></p>
<p>Enter your username and password of your Wikitude developer account and tap the login button to get to your user account. If you don&#39;t have a developer account yet register at the <a href='http://www.wikitude.com/developer/sign-in?p_p_id=58&p_p_lifecycle=0&p_p_state=maximized&p_p_mode=view&saveLastPath=0&_58_struts_action=%2Flogin%2Fcreate_account' target='top'>Wikitude developer page</a>.</p>
<p><img src="images/WT8_Android_DeveloperLogin.png" alt=" "></p>
<p>In this view, tap on the text box below the <code>Launch via URL</code> label and enter the URL of your ARchitect World. After tapping the <code>Launch</code> button your AR experience will be opened in Wikitude.</p>
<p><img src="images/WT8_Android_TestWorld.png" alt=" "></p>
<p><a id="on_device_debugging"></a></p>
<h2 id="on-device-debugging">On-Device Debugging</h2>
<p>Remote debugging is only available for devices running Android 4.4</p>
<p>To enable remote debugging of a WebView add the following line to your CamActivity.</p>
<pre><code class="lang-java">if(Build.VERSION.SDK_INT &gt;= 19) {
    WebView.setWebContentsDebuggingEnabled(true);
}
</code></pre>
<p><code>setWebContentsDebuggingEnabled</code> is available for Android 4.4+, you may need to capsule that to avoid runtime errors on devices running Android lower version 4.4. Additionally set <code>TargetSDK</code> to 19 in your Android Manifest.</p>
<p>To actually start debugging  follow the steps outlined on the official <a href="https://developers.google.com/chrome-developer-tools/docs/remote-debugging">Android Developer site</a>.</p>

<h2 id="3d-assets-workflow">3D Assets Workflow</h2>
<h4 id="prerequisites">Prerequisites</h4>
<ul>
<li>A 3D model in FBX (.fbx) file format (FBX up to version 2015)</li>
<li>Wikitude 3D Encoder for Windows or MacOS X</li>
</ul>
<p>3D content within the Wikitude SDK can only be loaded from so-called <em>Wikitude 3D Format</em> files (.wt3).  This is a compressed binary format for describing 3D content, which is optimized for fast loading and handling of 3D content on mobile devices. You still can use 3D models from your favorite 3D modeling tools (like Autodesk® Maya® or Blender), but need to convert them into wt3 file format using the Wikitude 3D Encoder (encoder for short).  The Encoder loads Autodesk® FBX® files (.fbx) and exports them to .wt3 files.</p>
<p>This section should give an overview on how to choose the right 3D models for displaying it in Wikitude&#39;s augmented reality SDK. As Wikitude is basing 3D support on a converted file format (.wt3) it is good to follow the best practices below.</p>
<h3 id="input-format">Input format</h3>
<h4 id="supported-3d-model-files-for-encoding-wt3-files-are-">Supported 3D model files for encoding wt3 files are:</h4>
<ul>
<li>FBX (.fbx) - max version: FBX 2015</li>
</ul>
<h4 id="features-you-can-use-in-your-3d-model-source-files-">Features you can use in your 3D model source files:</h4>
<ul>
<li>Mesh types<ul>
<li>Triangle-based meshes: The 3D models usually consist on a hierarchy of scenes nodes where the leaf nodes contain parts of a 3D mesh.</li>
<li>Skin-based meshes: mesh vertices a placed relative to a list of joint nodes, so-called bones. </li>
</ul>
</li>
<li><a href="#working-with-3d-animations">Animations</a><ul>
<li>Key-frame-based transformations/rotations/scalings applied to mesh vertices or scene nodes.</li>
<li>Bone animations for skin-based models.    </li>
</ul>
</li>
<li>Textures<ul>
<li>All textures are converted to the PNG file format during the import. The converter accepts textures of the usual picture file formats, like JPEG, GIF, TIFF, ...</li>
</ul>
</li>
<li>Lights<ul>
<li>Diffuse (Lambert) lighting by specifying a directional light source.</li>
<li>Specular (Phong) lighting by specifying specular light source (direction and specular exponent).
Several light sources can be used within a scene. However, only one light source (including diffuse+specular light) can be used for each mesh part, i.e., scene node. Thereby the light source which is closest to the scene node within the scene hierarchy (by traversing the tree upwards) is used. That is, a light source specified as a root node will be applied to all mesh parts in a scene. Other light sources will be applied to all mesh parts which are lower in the scene hierarchy.</li>
</ul>
</li>
<li>NURBS (will be tessellated on import)</li>
<li>Transparency<ul>
<li>Semi-transparent surfaces, like windows of a car, can visualized. , but only one semi-transparent layer can be visualized accordingly. The result of rendering several semi-transparent layers upon each other is </li>
</ul>
</li>
<li>Model size: There is no limit on the size of the 3D models in terms of numbers of mesh vertices or textures. However, for rendering the 3D models fluently on mobile devices we recommend to keep the total file size below 5-10 MB and the number of mesh vertices below 100k.     </li>
</ul>
<h3 id="features-that-are-not-yet-supported">Features that are not (yet) supported</h3>
<ul>
<li>bump maps/normal maps (normals are only evaluated on mesh vertices)</li>
<li>multi-textured surfaces (more than one texture on the same mesh)</li>
<li>multiple transparent layers (transparent layers are not depth queued)</li>
<li>animated textures on 3D models</li>
<li>height maps</li>
</ul>
<h2 id="good-practice">Good practice</h2>
<h4 id="use-png-textures">Use png textures</h4>
<p>Textures are stored in png format within wt3 files. While Wikitude 3D Encoder takes care of automatically converting textures to png, it is good practice to use png textures in the source 3D Model file.</p>
<h4 id="use-power-of-2-textures">Use power of 2 textures</h4>
<p>The rendering hardware on mobile devices often requires expects textures to have dimensions which are a power of 2 textures (e.g. 64x64, 128x128, ...). Other texture dimensions can lead to unexpected results. Additionally, using power-of-2 textures yields a better rendering performance. </p>
<h4 id="validate-texture-paths">Validate texture paths</h4>
<p>Textures can be stored within the FBX file or referenced by a file path. In the latter case, make sure to not use absolute paths since these often are not valid on other machines. Instead use relative paths. Texture files are also searched in the directory which contains the FBX file. We therefore recommend to provide external textures files in the same directory as the 3D model, i.e. the FBX file, itself. </p>
<h4 id="keep-texture-sizes-as-low-as-possible">Keep texture sizes as low as possible</h4>
<p>Keeping texture sizes as low as possible, while maintaining the required details has several benefits. The exported .wt3 file will be smaller and therefore quicker to load. And your application will require less memory.</p>
<h4 id="use-only-one-light">Use only one light</h4>
<p>To maintain a good rendering performance each part of your model (node) is only affected by a single light source. You may use multiple lights in the source file but at render time only a single node is selected to affect a mesh part. We make a best guess, utilizing the scene graph to assign a light to the node. If lighting is not required simply remove the lights from your source 3D model file and/or set the corresponding material properties. This helps to speed up rendering.</p>
<h3 id="resolving-problems">Resolving problems</h3>
<p>Different 3D modeling tools encode the 3D models differently during the FBX export which may lead to different rendering results when viewing the 3D models with other applications. We therefore recommend to verify your 3D model with the free Autodesk &quot;FBX Reviewer&quot;. </p>
<h4 id="3d-model-which-uses-joints-bones-is-distorted">3D Model which uses joints (bones) is distorted</h4>
<p>Create a root joint node such that all other joint nodes share the same root node.</p>
<h4 id="3d-model-shows-up-correctly-in-wikitude-3d-encoder-but-does-not-show-on-the-device-">3D Model shows up correctly in Wikitude 3D Encoder but does not show on the device.</h4>
<p>Check the file size of your wt3 file. Limiting the textures to the lowest size that maintains the required details. Keep the number of mesh vertices reasonable such that your targeted mobile device can cope with it. </p>
<h4 id="textures-are-missing">Textures are missing</h4>
<p>Check the error/warning dialog during the import process of the model it will give you detailed information on which textures are problematic. Make sure the texture paths are valid and accessible.</p>
<p><a id="working-with-3d-animations"></a></p>
<h2 id="working-with-3d-animations">Working with 3D Animations</h2>
<h4 id="quick-start">Quick start</h4>
<p>Export a model that contains one or more animations to a FBX file. After you load the 3D model into the Wikitude 3D Encoder the animations are displayed in a list on the right-hand side of your application window.</p>
<p><img src="images/encoder_animation_01.png" alt="Animation listed in Wikitude 3D Encoder"></p>
<p>Each row of the list contains the ID of the animation, a control button and the time that passed after you started the animation. Clicking the play button  will start the animation  from the beginning and play back the animation in the 3D view of the application. The stop button will stop animation and displays the frame, that was drawn last.</p>
<p>Check if your model looks and animates as expected and export it to a wt3 file. You need the  IDs of the animations you want to use in your application. The IDs are displayed next to the animation control button (on the screenshot the animation ID is <em>butterfly_animation</em>). In your code you start an animation like this.</p>
<pre><code class="lang-js">// instantiate the model object
var model = new AR.Model(&quot;butterfly.wt3&quot;);

// instantiate the model animation with the animation id
var animation = new AR.ModelAnimation(model, &quot;butterfly_animation&quot;);

// start the animation
animation.start();
</code></pre>
<h4 id="export-animations">Export Animations</h4>
<p>The Wikitude 3D Encoder supports animation of joints and transformation animations. This includes transformation animations along motion paths.</p>
<p>When exporting the model from the 3D modeling tool you have to <strong>bake</strong> your animations. For example, Maya bakes all unsupported constraints, including Maya-supported and FBX constraints, into animation curves.</p>
<h4 id="grouping-animations">Grouping Animations</h4>
<p>Animations will be grouped automatically to a top level node. In order to create two separate animations you need to group them in your modeling tool accordingly.</p>
<p>To illustrate that let&#39;s create an example with 3 spheres and 3 cylinders with different translation animations. In the scene graph this example looks like the following:</p>
<pre><code>• sphere1
• sphere2
• sphere3
• cylinder1
• cylinder2
• cylinder3
</code></pre><p>Once the example is exported to FBX and imported into the Wikitude 3D Encoder  six separate animations, one for each object, will be generated.</p>
<p>Let&#39;s assume we want to group all sphere animations into one animation and all cylinders into a second animation. This can be achieved by creating two separate groups. One group containing all spheres and another one containing all cylinders. In the scene graph this is going to look like this:</p>
<pre><code>• all_spheres_group
  • sphere1
  • sphere2
  • sphere3
• all_cylinders_group
  • cylinder1
  • cylinder2
  • cylinder3
</code></pre><p>Export this to FBX and import it into the Wikitude 3D Encoder we would get the desired result: one animation that animates all spheres and another animation animating all cylinders.</p>
<p><em>Note: Do not group joints, especially when they were already skinned to a mesh.</em></p>
<h4 id="known-issues">Known Issues</h4>
<ul>
<li>In Blender avoid transformations on bones before you skin them to a mesh and export it to an FBX file.</li>
<li>Exporting a 3D model with animations from Blender to FBX creates additional animations for camera, lights or motion paths. These can be safely ignored.</li>
</ul>

<h2 id="augmented-reality-videos">Augmented reality videos</h2>
<p>Videos in an augmented reality scene are an effective way to provide a spectacular experience to your users. Videos can run in <strong>three modes</strong> and can come from <strong>different sources</strong>. In general you can&#39;t upload videos to the Wikitude backend but need to use self-hosted videos or videos from an online video service (like YouTube).</p>
<p>Available modes:</p>
<ul>
<li><a href="#fullscreen">Fullscreen Videos</a></li>
<li><a href="#overlay">Overlay Videos</a></li>
<li><a href="#overlayalpha">Overlay Videos with transparency (alpha channel)</a></li>
</ul>
<p>Supported video sources:</p>
<ul>
<li><a href="#selfhosted">Self-hosted video</a></li>
<li><img src="images/YouTube_Logo.png" style="vertical-align:middle;"></img> <a href="#youtube">YouTube</a></li>
<li><img src="images/Vimeo_logo.png" style="vertical-align:middle;"></img><a href="#vimeo">Vimeo</a></li>
</ul>
<p><a id="fullscreen"></a></p>
<h3 id="fullscreen-videos">Fullscreen Videos</h3>
<p>Fullscreen videos are video files that play back in the native player of the device of the user. Instead of playing directly in the live camera, fullscreen videos will open a separate window and start the video player. When the user clicks back or closes the window will bring back the user to the augmented reality experience.</p>
<p><img src="images/fullscreenvideo_ios.jpg" alt="Fullscreen video in iOS 7"></p>
<p><img src="images/fullscreenvideo_android.jpg" alt="Fullscreen video in Android"></p>
<p><a id="overlay"></a></p>
<h3 id="overlay-videos">Overlay Videos</h3>
<p>Overlay or augmented reality videos play back directly in the live camera view on top of an image or at a specific geo location. You can choose the size of the video and the position of it. </p>
<p>Note: In order for overlay images to work they need to be encoded with a certain video codec (H.264). The chapter <a href="#codecs">video codecs</a> describes in detail. Also not all devices are capable of play back an overlay video - read the chapter <a href="#devices">supported devices</a> for details.</p>
<ul>
<li><strong>Self-hosted videos:</strong> Make sure to use H.264 encoded files, but other than that self-hosted files can be used as overlay videos.</li>
<li><strong>YouTube:</strong> Videos hosted on YouTube can <strong>not</strong> be used directly for overlay videos due to license restrictions. If you have access to the source video file, encode it into a H.264 video file, upload it to your server and you are good to go. </li>
<li><strong>Vimeo:</strong> Videos hosted on vimeo can <strong>not</strong> be used directly for overlay videos due to license restrictions. If you have access to the source video file, encode it into a H.264 video file, upload it to your server and you are good to go. </li>
</ul>
<p><img src="images/simple_videos.jpg" alt=""></p>
<p>Overlay videos will play back immediately if this option is selected or otherwise start with the play back once the user clicks on the video. The video will pause and resume if user is moving away from the target image containing the video.</p>
<p><a id="overlayalpha"></a></p>
<h3 id="overlay-videos-with-alpha-channel">Overlay Videos with alpha channel</h3>
<p>Beside standard videos Wikitude Studio can also handle videos with transparent background (alpha channel). Like transparent images, videos can have a transparent background.</p>
<p><img src="images/transparent_video_1.jpg" style="width:300px;"></img> <img src="images/transparent_video.jpg" style="width:300px;"></img></p>
<p>Producing a transparent video is usually done using a green screen for filming and a technique called chroma key to replace the green background with transparency. Extensive information is available on the internet that should help you get started on this topic. </p>
<p>There are different video codecs that support alpha channels for motion picture and most of them will work as your raw material. We have extensively tested Apple ProRes 4444 codec for our own development and were satisfied with the results.</p>
<p>The Wikitude SDK can only render H.264 encoded videos, which is a codec that in practice does not support an alpha channel. The solution here is to include the alpha channel in a separate (visible) part of the video. The video is split vertically consisting of a color and a alpha channel in the final video below each other. The following image shows how the preprocessing result should look like.</p>
<p><img src="images/video_h264_transparent.png" alt=""></p>
<p>The upper half of the image transports the color information for the final video while the lower half includes a grayscale representation of the alpha layer. White areas will be fully opaque and black areas will be fully transparent. If you are familiar with Photoshop, think of the lower half as a mask. <strong>Resulting videos have an height that is exactly twice as big as the input video.</strong></p>
<p>To convert your raw video to a valid input video for the Wikitude Studio you need to re-encode the video and automatically create the alpha mask. The script below included in the Wikitude SDK (separate <a href="http://www.wikitude.com/download" target="_top">download</a>) uses <code>ffmpeg</code> to do so and wraps the necessary commands. Follow these simple steps:</p>
<h4 id="macos-x">MacOS X</h4>
<ol>
<li>Open the Terminal application</li>
<li>Input <code>cd &lt;SDK&gt;/tools/video/MacOSX</code>. Replace <code>&lt;SDK&gt;</code> with the path to the SDK folder</li>
<li>Execute <code>sh convert.sh &lt;input video&gt; &lt;output video&gt;</code>. Replace <code>&lt;input video&gt;</code> with the path to your transparent video and <code>&lt;output video&gt;</code> with the path where you want the output video to be stored.</li>
</ol>
<h4 id="windows">Windows</h4>
<ol>
<li>Open the Command Line</li>
<li><code>cd &lt;SDK&gt;\tools\video\Windows</code>. Replace <code>&lt;SDK&gt;</code> with the path to the SDK folder</li>
<li>Execute <code>convert.bat &lt;input video&gt; &lt;output video&gt;</code>. Replace <code>&lt;input video&gt;</code> with the path to your transparent video and <code>&lt;output video&gt;</code> with the path where you want the output video to be stored.</li>
</ol>
<p>This creates the required video with a vertically split color and alpha channel.</p>
<h4 id="position-a-video-containing-an-alpha-channel-in-the-wikitude-studio">Position a video containing an alpha channel in the Wikitude Studio</h4>
<p>The video you are uploading will be twice as high as the video the user is going to see. Make sure to consider this when placing the video on your target image. </p>
<p><a id="selfhosted"></a></p>
<h3 id="self-hosted-videos">Self-hosted Videos</h3>
<p>You can use any URL or link to a video, which is publicly accessible. This can anything from a link to a file in the public folder of Dropbox to a link to a video on your own server. Just make sure to comply with the supported video <a href="#codecs">codecs</a> if you like to use <a href="#overlay">overlay videos</a> or <a href="#overlayalpha">overlay videos with alpha channel</a>.</p>
<p><a id="youtube"></a></p>
<h3 id="videos-from-youtube">Videos from YouTube</h3>
<p><img src="images/YouTube_Logo.png" style="vertical-align:middle;"></img></p>
<p>The video augmentation will automatically recognize if you enter a URL to a YouTube video (like <a href="http://www.youtube.com/watch?v=yFU774q6eVM">http://www.youtube.com/watch?v=yFU774q6eVM</a>). YouTube videos can <strong>not</strong> be used for <a href="#overlay">overlay videos</a> or <a href="#overlayalpha">overlay videos with alpha channel</a> due to license restrictions. <strong>YouTube videos will always be play back in fullscreen mode.</strong></p>
<p>You can select the default thumbnail image provided by YouTube or upload your own thumbnail image.</p>
<p>When you resize and position the augmentation you are actually resizing and positioning the thumbnail image.</p>
<p><a id="vimeo"></a></p>
<h3 id="videos-from-vimeo">Videos from Vimeo</h3>
<p><img src="images/Vimeo_logo.png" style="vertical-align:middle;"></img> </p>
<p>The video augmentation will automatically recognize if you enter a URL to a video file hosted on vimeo. Videos on vimeo can be used for <a href="#fullscreen">fullscreen</a> videos only. Entering a link to a vimeo video (like <a href="https://vimeo.com/51396462">https://vimeo.com/51396462</a>) will play back the video in <strong>fullscreen mode only</strong>. </p>
<p><a id="thumbnails"></a></p>
<h3 id="thumbnail-images">Thumbnail images</h3>
<p>Thumbnails are the images, which are shown to your user, when the video hasn&#39;t been started. They are preview images for your users so that they know what to expect. Wikitude Studio can either download the default thumbnail image from a video provider (YouTube or vimeo) and use this as the thumbnail. Or alternatively you can upload a custom thumbnail image for your video. The image can be any size and any picture you like. </p>
<p><strong>Note</strong> The Wikitude Studio does not add any play buttons to the thumbnail image.</p>
<p><a id="h264browser"></a></p>
<h3 id="browser-and-h-264-support">Browser and H.264 support</h3>
<p>You are very likely encountering a <code>No show today</code> error in Wikitude Studio. This means that your browser can&#39;t play back the selected video. Some browsers do have difficulties (Firefox) to play back H.264 encoded files directly in the browser. However this only means that we can&#39;t show you a pretty preview of your video playing directly in the Wikitude Studio. If you have chosen the correct <a href="#codecs">codec</a> <strong>your augmented reality experience will just work fine. </strong></p>
<p><a id="devices"></a></p>
<h3 id="supported-devices">Supported Devices</h3>
<p>In general videos are fully supported on devices running iOS 6+ and Android 4.0+. Other devices will still play back the video but only in fullscreen mode as a fall-back solution. </p>
<ul>
<li>iOS 6.0 or newer: full support</li>
<li>iOS 5.x or older: only fullscreen videos</li>
<li>Android 4.0 or newer: full support</li>
<li>Android 3.x or older: only fullscreen videos</li>
</ul>
<p>The Wikitude SDK in the background is detecting the appropriate mode accordingly. This means that your user is trying to play back a overlay video with a non-capable device, the video will be played back in fullscreen mode.</p>
<p><strong>Summary: Only iOS 6+, Android 4.0+ devices will play back overlay videos. All other devices will show a fullscreen video.</strong></p>
<p><a id="codecs"></a></p>
<h3 id="supported-video-codecs">Supported Video Codecs</h3>
<p>Unfortunately support of video throughout mobile devices is not straight forward. Devices and operating system differ in what videos they can play back and which videos they reject. To support all platforms the best solution is to use an H.264 encoded video with a maximum resolution of 720p (1280x720 pixel). To make things even more confusing the H.264 codec defines different profiles. Not all of them play back nicely so make sure that you are using either one of the following</p>
<ul>
<li>Baseline</li>
<li>Extended</li>
<li>Main</li>
</ul>
<p>The recommendation for Android and iOS with broad support is to use H.264 (AVC) as codec (Baseline profile) with .mp4 as container format. For full list of media support on Android see <a href="http://developer.android.com/guide/appendix/media-formats.html" target="_top">the official guide</a> or <a href="https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/CreatingVideoforSafarioniPhone/CreatingVideoforSafarioniPhone.html" target="_top">iOS web guide</a>.</p>
<div class="tip">
Do not use Quicktime movies or .avi movies, as their codec is not support on both Android and iOS.
</div>

<p>If the profile differs especially Android devices will most certainly misbehave (fail to play or crash entirely) when playing back those videos. </p>
<p>Here at Wikitude we use the app Handbrake for transcoding existing videos to the correct format. Below you see a screenshot with the settings we are using </p>
<ol>
<li>H.264 codec</li>
<li>Baseline profile</li>
<li>Limiting max video bitrate to 1250 kbps</li>
</ol>
<p><img src="images/video_guide_handbrake.png" alt=""></p>
<div class="tip">
Summary: For overlay videos use H.264 encoded videos with baseline profile in a mp4 container.
</div>

<h1 id="tools">Tools</h1>
<p>In this section of the documentation we are covering tools shipped with the Wikitude SDK, which help you in your development. </p>
<ol>
<li><a href="ade.html">ADE</a></li>
<li><a href="logger.html">Logger</a></li>
<li><a href="targetmanagement.html#target-management">Target Manager</a></li>
<li><a href="targetguide.html">Best practice for target images</a></li>
<li><a href="encoder.html">Wikitude 3D Encoder</a></li>
</ol>

<h2 id="ade">ADE</h2>
<p>The ARchitect Desktop Environment (ADE) allows you to simulate the
behavior of your ARchitect file on an ordinary web browser, and observe the
properties of your AR objects and simulate user interaction and events.</p>
<h3 id="how-can-i-enable-the-ade-for-my-architect-file-">How can I enable the ADE for my ARchitect file?</h3>
<p>To enable ADE functionality, simply add the ade.js file included in the
ARchitect Tools to the list of imported scripts in the header-section of
your ARchitect file:</p>
<pre><code class="lang-html">&lt;html&gt;
    &lt;head&gt;
        &lt;script src=&quot;architect://architect.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;[your_path_to_the_ade_file]/ade.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    ...
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Next, open the ARchitect file in an ordinary web browser. Your browser will immediately render the HTML content specified in your ARchitect file, as well as starting to execute the provided JavaScript functionality.</p>
<p>When the file was successfully loaded, you will see your specified HTML content at top of the page. Immediately below your HTML content, you will see the list of ARchitect objects that you have  created (if you did not yet create any ARchitect objects, you will only see the
automatically generated &quot;context&quot; object). This list represents all ARchitect objects known to the system, and the list will be automatically updated as soon as new objects are created or existing ones are modified.</p>
<p>The list will always specify the type of the ARchitect object (for example <code>GeoLocation</code>) and the id of the object, which is stored in the immutable <code>__id</code> property.</p>
<p><img src="images/image05.png" alt="An example of an ADE tree" title="Example of ADE tree"></p>
<p>For instance, the second line in the list represents a GeoLocation with the <code>__id</code> property set to <code>a_0</code>.</p>
<h3 id="how-can-i-use-the-ade-">How can I use the ADE?</h3>
<p>As soon as you create new ARchitect objects, they will appear in the list. Click on the &#39;+&#39; symbol next to the object&#39;s description to expand it and observe the values of the object&#39;s properties defined in the ARchitect specification.</p>
<p><img src="images/image04.png" alt="Example of ADE tree with an expanded object" title="Example of ADE tree with expanded object"></p>
<p>Blue color-coding of a property indicates that the trigger or function is defined and can be executed; black color-coding indicates that the trigger or function is undefined and thus can not be executed. In the example above, we have defined an onExitFieldOfVision trigger. Clicking on the trigger will execute the specified function. If your trigger
changes a certain property of the GeoObject, you will immediately see the change in the above list of properties.</p>
<p>Additionally, you can simulate other events occurring in regards to certain objects. For a GeoObject, you can simulate that the GeoObject is in, or outside of the field of vision, of the user. Clicking on <code>Toggle Visibility</code> will simulate that the GeoObject is
coming into the field of vision, or is leaving the field of vision
respectively. Associated triggers will automatically be triggered (just as they are triggered on the mobile device), and the artificial property
`visible changes its value. Artificial properties are properties that
do not exist on a mobile device; they are solely used in the ADE to
simulate the status of the ARchitect object.</p>
<p>ARchitect objects, triggers and events will behave in the exact same way
in the ADE as they would on a mobile device. The only exception is the
PropertyAnimation object, which will not change the value over time and
according to the specified EasingCurve in the ADE, PropertyAnimations
will change the value only once at the end of the Animation, rather than
continuously.</p>

<h2 id="logger">Logger</h2>
<p>The JavaScript API comes equipped with a logging console that is shared by the system and the developer. </p>
<p>On start up of each world, the library creates a singleton <a href="../Reference/JavaScript%20API/classes/logger.html"><code>AR.logger</code></a> instance, which can be used by the developer to log messages.</p>
<p>To see the log messages, you need to call the JavaScript function <a href="../Reference/JavaScript%20API/classes/logger.html#method_activateDebugMode"><code>AR.logger.activateDebugMode()</code></a>. For example in the <code>body.onLoad</code> trigger:</p>
<pre><code class="lang-html">&lt;html&gt;
&lt;body onLoad=&quot;javascript:AR.logger.activateDebugMode();&quot;&gt;
    &lt;!-- your body content --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>When <a href="../Reference/JavaScript%20API/classes/logger.html#method_activateDebugMode"><code>activateDebugMode()</code></a> is called, it automatically creates a button at the bottom of your display, which allows you to open the Logging console. When you click the button, the logging window appears. Within this window, you can select the log-levels you would like to see, as well as close the logging console again.</p>
<p>Bear in mind that the system itself will also use the logging framework to log messages, thus allowing you to debug if anything unexpected happens.</p>
<p>Please remember to deactivate the logging framework before you actually publish your world by removing the call to <a href="../Reference/JavaScript%20API/classes/logger.html#method_activateDebugMode"><code>activateDebugMode()</code></a>. Otherwise, the users of your augmented reality experience will always see the button at the bottom of the page, and would be able to follow debug messages.</p>

<h2 id="target-management">Target Management</h2>
<p>This guide gives you an overview of how to create a target collection that you can use to detect and track images within your augmented reality experience.</p>
<p>In general the conversion can be done via three different tools:</p>
<ol>
<li>Web Target Manager Tool: A browser based tool to convert your images to a wtc file. You can find the tool under:  <a href="https://targetmanager.wikitude.com" target="_blank">https://targetmanager.wikitude.com</a>. You need your free developer account to log-in. This tool is described in more detail on further below</li>
<li>RESTful API. Make use of all features provided by the web tool via direct server endpoints.</li>
<li>Targets Enterprise Script: A binary shell script available for Mac OS X and Linux converting images to target collections. Pleases <a href="mailto:sales@wikitude.com">contact Wikitude Sales</a> team for technical requirements and pricing.</li>
</ol>
<p>The following images describes the relationship between the above mentioned methods and the Wikitude Cloud Recognition Service, which is not scope of this documentation. </p>
<p><img style="width: 500px" src="images/150212_WT_Infografik_OfflineOnlineRecognition_01.jpg"></p>
<h3 id="web-targetmanager">Web Targetmanager</h3>
<h3 id="add-a-new-project">Add a new project</h3>
<ul>
<li>Open <a href="https://targetmanager.wikitude.com" target="_blank">https://targetmanager.wikitude.com</a> and login with your Wikitude Developer account</li>
<li>Add a new project to your project collection</li>
</ul>
<p><img style="width: 500px" src="images/tmt_CreateProject.png"></p>
<h3 id="add-target-images">Add target images</h3>
<ul>
<li>Enter an existing project </li>
<li>Add new target images to the project either by clicking on <code>Add Targets</code> or drag  &amp; drop them on the empty area. Supported file formats include PNG and JPEG. If you are using PNG images, please make sure that it does not contain any transparent pixels, only solid colored images are supported.</li>
</ul>
<p><img style="width: 500px" src="images/tmt_AddTargets.png">    </p>
<ul>
<li>When uplaoding a target the file name is used as <code>target name</code>. It identifies a target in your experience. If the <code>target name</code> is not completely visible, hover over it to reveal the full name or double click the target to enter edit-mode.</li>
</ul>
<div class="warning">
<strong>Important</strong> <br />
If you add your own target images  you need the target name to set them in  <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>.</div>


<h3 id="star-rating">Star Rating</h3>
<ul>
<li><strong>0 stars:</strong> Not suitable for tracking. This target image cannot be tracked because it lacks textured features with high local contrast. Please consider choosing another target image.</li>
<li><strong>1 star:</strong>  Limited tracking ability. This target image provides basic tracking performance in good lightning conditions. Please consider improving the image</li>
<li><strong>2 stars:</strong> Good tracking ability. This target image will track well in most conditions.</li>
<li><strong>3 stars:</strong> Very good tracking ability. This target image will track very well in most conditions.</li>
</ul>
<p>General advice for reference images</p>
<ul>
<li>Good image characteristics:<ul>
<li>Diversely textured image with high local contrast</li>
</ul>
</li>
<li>Bad image characteristics:<ul>
<li>Large areas with solid color or smooth color transitions</li>
<li>Repetitive patterns</li>
<li>Logos, signs        </li>
</ul>
</li>
</ul>
<h3 id="create-a-wtc-file">Create a WTC file</h3>
<ul>
<li>AR.ClientTracker requires a WTC (Wikitude Target Collection) file which contains all information of the targets that should be recognized. Enter the project you need the file for and click the <em>WTC icon</em> in the toolbar.</li>
</ul>
<p><img style="width: 500px" src="images/tmt_CreateTargetCollection.png"></p>
<ul>
<li>Select the Wikitude SDK version you&#39;re using and click <em>Generate</em> to trigger the creation of the WTC file. You will be notified via e-Mai once the file is available for download.</li>
</ul>
<p><img style="width: 500px" src="images/tmt_TargetCollections.png"></p>
<h3 id="use-project-s-wtc-file-in-your-architect-world">Use project&#39;s WTC file in your ARchitect World</h3>
<p>Look at one of the <a href="clientrecognition.html">client recognition examples</a> or refer to the JavaScript API reference of <a href="../Reference/JavaScript%20API/classes/ClientTracker.html"><code>AR.ClientTracker</code></a> for instructions on how to use the created target collection for augmentations in your ARchitect Worlds.</p>
<h3 id="cloud-recognition">Cloud Recognition</h3>
<p>Any existing project may also be published to the Cloud to make it accessible for <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>. </p>
<p>Click the <em>Cloud icon</em> in the toolbar for more details.</p>
<p><img style="width: 500px" src="images/tmt_CloudIcon.png"></p>
<p>Cloud Recognition is available for free in your testing process but you must purchase a license for productive use. <a href="http://www.wikitude.com/external/doc/documentation/latest/cloudrecognition/gettingstartedcloudrecognition.html#quota-and-limits">Learn more</a></p>
<p><img style="width: 500px" src="images/tmg_CloudPublishing.png"></p>
<p>Once a project is published it is accessible via Wiktiude SDK using &#39;Client Token&#39; and &#39;Target Collection ID&#39; (compare <a href="../Reference/JavaScript%20API/classes/CloudTracker.html"><code>AR.CloudTracker</code></a>) </p>
<p><img style="width: 500px" src="images/tmt_CloudTracker.png"></p>
<p>Hints</p>
<ul>
<li><p>You may unpublish a project at any time but be aware that this action has immediate effect on your application(s) making use of the credentials.</p>
</li>
<li><p><strong>Metadata</strong> in the &#39;Edit Target&#39; dialog is solely relevant for Cloud Recognition whereat <strong>Physical Height</strong> is only relevant for distanceToTarget feature.</p>
</li>
<li><p>Leave <strong>Physical Height</strong> empty if you do not use the distanceToTarget feature of <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObject</code></a>.</p>
</li>
<li><p>The <strong>Metadata</strong> field is very useful. It allows you to attach JSON data to a target. That way you can define any kind of additional data and react on it dynamically in the SDK to e.g. let a button refer to a details page which is defined in the Metadata JSON.</p>
</li>
</ul>
<p><img style="width: 500px" src="images/tmt_CloudTargetEdit.png"></p>

<h2 id="best-practice-for-target-images">Best practice for target images</h2>
<p>This guide gives you an overview of how to create a target collection that you can use to detect and track images within your ARchitect World.</p>
<h3 id="summary">Summary</h3>
<p><strong>Preferred images have:</strong></p>
<ul>
<li>between 500 to 1000 pixels in each dimension</li>
<li>Rich contrast</li>
<li>Evenly distributed textured areas</li>
<li>Many corner like structures</li>
</ul>
<p><strong>Unsuitable images have:</strong></p>
<ul>
<li>Smaller dimensions than 500 pixels</li>
<li>Larger than 1000 pixels as they do not provide more accurate results</li>
<li>Large amounts of text</li>
<li>Many repetitive patterns</li>
<li>Large single-colored areas </li>
<li>Color contrast only e.g. green to red edge), because all images are processed as grayscale images</li>
</ul>
<h3 id="optimal-image-dimensions">Optimal Image Dimensions</h3>
<ul>
<li>Optimal images are sized between 500 and 1000 pixels in each dimension</li>
<li>Small images do not contain enough graphical information to extract so called feature points. The uniqueness, amount and distribution of features points are the key indicators for good detection and tracking quality</li>
<li>Larger images do not improve the tracking quality
<img src="images/guide_dimension_wrong.png" alt="Target image too small">
<img src="images/guide_dimension_good.png" alt="Optimal size of target image"></li>
</ul>
<h3 id="low-contrast-images">Low contrast images</h3>
<ul>
<li>Images with high local contrast and large amount of rich textured areas is best suited for reliable detection and tracking</li>
<li>Color contrast only (i.e. green to red edge) appears as high contrast to the human eye but is not discriminative to computer vision algorithms as they are operating on grayscale images
<strong><em>Tip</em></strong>: For low contrast images, try to increase the contrast of your target image with an image editing tool like Gimp or PhotoShop to improve detection and tracking quality</li>
</ul>
<p><img src="images/low_contrast_wrong.png" alt="Target image with low contrast">
<img src="images/low_contrast_good.png" alt="Target image with good contrast"></p>
<h3 id="distribution-of-textured-areas">Distribution of textured areas</h3>
<ul>
<li>Images with evenly distributed textured areas are good candidates for reliable detection and tracking</li>
<li>This might be the hardest part to be in control of and often can’t be changed.
<strong><em>Tip</em></strong>: Try to crop the most prominent part of your image and use only this as target image.</li>
</ul>
<p><img src="images/texture_distribution_wrong.png" alt="Target image with not optimal distribution">
<img src="images/texture_distribution_good.png" alt="Even distribution of features"></p>
<h3 id="images-with-whitespace">Images with whitespace</h3>
<ul>
<li>Single-colored areas or smooth color transitions often found in backgrounds do not exhibit graphical information suitable for detection and tracking. 
<strong><em>Tip</em></strong>: Try to crop the most prominent part of your image and use only this as target image.</li>
</ul>
<p><img src="images/whitespace_wrong.png" alt="Too much whitespace">
<img src="images/whitespace_good.png" alt="Image reduced to the most relevant part"></p>
<h3 id="vector-based-graphics">Vector-based graphics</h3>
<ul>
<li>Logos and vector-based graphics usually consist of very few areas with high local contrast and textured structures and are therefore hard to detect and track. </li>
</ul>
<p><strong><em>Tip</em></strong>: Try to add additional elements to the graphic like your logotype or any other specific elements, which can go along with your graphic.</p>
<p><img src="images/vector_wrong.png" alt="Vector-based image">
<img src="images/vector_good.png" alt="Target image mixed with graphic elements"></p>
<h3 id="images-with-a-lot-of-text">Images with a lot of text</h3>
<ul>
<li>Images consisting primarily of large areas of text are hard to detect and track.</li>
</ul>
<p><strong><em>Tip</em></strong>: Try to have at least some graphical material and images next to your text for your target image.</p>
<p><img src="images/text_wrong.png" alt="Pure text">
<img src="images/text_good.png" alt="Text mixed with graphic elements"></p>
<h3 id="repetitive-patterns">Repetitive patterns</h3>
<ul>
<li>Repetitive patterns exhibit the same graphical information information at each feature point and therefore cannot be localized reliably</li>
<li>Images with slightly irregular structures can convey a similar information to the target audience while providing enough unique feature points to be detected (second image)</li>
</ul>
<p><strong><em>Tip</em></strong>: Try a different selection of your image including non pattern parts or use images with irregular patterns</p>
<p><img src="images/patterns_wrong.png" alt="Repetitive patterns that do not track">
<img src="images/patterns_good.png" alt="Pattern with irregular structures"></p>

<h2 id="wikitude-3d-encoder">Wikitude 3D Encoder</h2>
<p>3D content within Wikitude can only be loaded from so-called <em>Wikitude 3D Format</em> files (.wt3).  This is a compressed binary format for describing 3D content, which is optimized for fast loading and handling of 3D content on a mobile devices. You still can use 3D models from your favorite 3D modeling tools (such as Autodesk® Maya® or Blender) but you&#39;ll need to convert them to the wt3 file format. Wikitude offers a desktop application called the Wikitude 3D Encoder, which handles the task of
encoding your 3D source file.  The Wikitude Encoder currently supports Autodesk® FBX® files (.fbx) for encoding to .wt3.  </p>
<p>The Wikitude 3D Encoder converts 3D models into an internal representation, so-called wt3 files, which can then be rendered by the Wikitude SDK. The converter supports mesh-based 3D models which can be animated, textured and lit by light sources. </p>
<p>Each step for getting a .wt3 file from your 3D content is explained in more detail below.</p>
<ol>
<li>How to install the Wikitude 3D Encoder</li>
<li>Supported 3D Models</li>
<li>The Wikitude 3D Encoder user interface</li>
<li>First Steps Using the Wikitude 3D Encoder</li>
<li>Working with 3D Models</li>
</ol>
<h3 id="how-to-install-wikitude-3d-encoder-on-windows-xp-windows-7-windows-8">How to install Wikitude 3D Encoder on Windows XP/ Windows 7/ Windows 8</h3>
<ul>
<li>Download the Encoder from <a href="http://www.wikitude.com/download" target="_top">www.wikitude.com/download</a></li>
<li>Run the setup.exe installation file and follow the installation wizard</li>
</ul>
<h3 id="how-to-install-wikitude-3d-encoder-on-mac-os-x">How to install Wikitude 3D Encoder on Mac OS X</h3>
<ul>
<li>Download the Encoder from <a href="http://www.wikitude.com/download" target="_top">www.wikitude.com/download</a></li>
<li>Open the .dmg installation image and drag the Wikitude 3D Encoder application to your Applications folder.</li>
</ul>
<h3 id="supported-3d-models-input-files-">Supported 3D Models (Input Files)</h3>
<p>The Wikitude 3D Encoder can import Autodesk® FBX® up to version 2015. Though the FBX format is not a well defined standard it is supported by most 3D modeling tools, like Autodesk Maya or 3D Studio Max, and thereby represents a common 3D file format. Since different modeling tools use different representations of the 3D models we recommend to verify the models in the free tool &quot;FBX Reviewer” by Autodesk (<a href="http://area.autodesk.com/products/features/fbx" target="_top">Download</a>). </p>
<p>Features you can use in your 3D model source files:</p>
<ul>
<li>Static model (made-up of triangles)   </li>
<li><a href="assetsworkflow.html#working-with-3d-animations">Animations</a><ul>
<li>Transformation Animations</li>
<li>Skinning</li>
</ul>
</li>
<li>Materials<ul>
<li>Phong, Lambert, Blinn</li>
<li>Transparency</li>
</ul>
</li>
<li>NURBS (will be tessellated on import)</li>
</ul>
<p>Features that are not (yet) supported</p>
<ul>
<li>Normal Mapping</li>
<li>Multi Textures</li>
</ul>
<p>If you are not sure whether the 3D model at hand fits the requirements, try to encode it. You will receive a list of warnings and errors that tell you if the 3D content will work within Wikitude or uses unsupported features.</p>
<h3 id="the-wikitude-3d-encoder-user-interface">The Wikitude 3D Encoder user interface</h3>
<p>On startup you are presented with the following interface.</p>
<ol>
<li>Toolbar for frequently used functions</li>
<li>3D working area to view your 3D content.</li>
<li>Scene graph that lists all 3D content in a tree view</li>
<li>A properties area that shows details about a selected node from the scene graph</li>
<li>Status bar</li>
</ol>
<p><img src="images/Wikitude3DEncoderInterface.png" alt="Wikitude 3D Encoder Interface"></p>
<h3 id="first-steps-using-the-wikitude-3d-encoder">First steps using the Wikitude 3D Encoder</h3>
<p>Start by opening a supported 3D model file (.fbx, .dae). Select <code>Open</code> from the toolbar or drag and drop a supported file onto the 3D working area. Depending on the size of the file this can take a while. Once finished, the 3D content will be shown in the 3D working area.</p>
<p>In case the Wikitude 3D Encoder encounters features not supported in your file, it will present a list of errors or warnings in a dialog box. The popup window summarizes the issues found during the import process. You can bring up this information again at a later time via <code>Window-&gt;Show Logging Window</code>. Check the message and details carefully to identify areas that need to be altered in your 3D model file, ensuring that it can be encoded properly.</p>
<p>The 3D working area shows your encoded 3D model file in the exact way as it would show in Wikitude. Drag, pan and zoom to verify that your model looks ok.  If you need to check specific properties (e.g. materials or lights) select the corresponding node in the scene graph. The details of a selected node are displayed in the properties view.</p>
<h3 id="export-files-to-wt3">Export files to .wt3</h3>
<p>Once you are satisfied with the encoded file, choose <code>Export</code> from the toolbar. Then choose the location where the exported file should be saved. Exported .wt3 files can be used directly in an augmented reality experience using Wikitude. If you want to view a .wt3 file on the desktop, simply choose <code>Open</code> or drag and drop it into the Wikitude 3D Encoder.</p>
<p>More information on the workflow with 3D content can be found in the dedicated chapter called <a href="assetsworkflow.html">3D Asset Workflow</a>.</p>
<h3 id="scene-graph-and-animations">Scene Graph and Animations</h3>
<p>The scene graph contains all mesh parts of the 3d model grouped into a hierarchy. The leafs of the scene graph represent different parts of the 3D model. Selecting nodes in the scene graph displays a bounding box indicating where the part is located in the 3d model (see white frame box in the figure below). </p>
<p>A list of all model parts can be obtained via the application menu or by selecting node and copying its name, either via the context menu or by key combination Command+c/Control+c (see figure below). </p>
<p>If a 3D model contains animations, these are listed on the right-hand side of the window. Each animation can be started by the round play button  (see figure below). </p>
<p>For a discussion on how to use model parts and animations in the Wikitude SDK see <a href="3dmodels.html"><code>3D Models</code></a></p>
<p><img src="images/car_animated_3dencoder.png" alt="Wikitude 3D Encoder - Lists of model parts and animations."></p>

<h1 id="reference">Reference</h1>
<h2 id="android-javadocs">Android JavaDocs</h2>
<p>Go to <a href="../Reference/Android%20Architect%20SDK%20API/html/index.html">Android JavaDoc Reference</a> for a complete reference of all Android Wikitude API objects and functions.</p>
<h2 id="javascript-api">JavaScript API</h2>
<p>Go to <a href="../Reference/JavaScript%20API/index.html">JavaScript API Reference</a> for a complete reference of all JavaScript API objects and functions.</p>
<h2 id="cloud-recognition-manager-api">Cloud Recognition Manager API</h2>
<p>Go to <a href="../Reference/Cloud%20Recognition%20REST%20API/index.html">REST API Reference</a> for a complete reference of all REST API calls for the Manager API.</p>

<h2 id="sdu-and-dbs">SDU and DBS</h2>
<h3 id="scaled-distance-units-sdus-">Scaled Distance Units (SDUs)</h3>
<p>In AR applications, the term &quot;size of an object&quot; cannot be defined just in pixels or similar size measurements. Unlike in 2-dimensional applications, such as maps, the size of an object inherently depends on the distance from the viewer to the object.</p>
<p>Imagine a virtual 2-dimensional logo which should be placed right on top of a certain store location. In a map-based application, the size can easily be defined by specifying the width and height of the logo in pixels. In AR applications, the logo should appear as big as the building itself, which is dependent on the distance in a natural way. Additionally for geobased use cases objects should be readable even if far away. We use a distance based scaling (see below) to accomplish this.</p>
<p>The term &quot;pixels&quot; or physical units cannot be used in AR applications, as they are defined in a static way and do not allow the application to scale the objects in the desired way. Thus, the Wikitude ARchitect introduces Scaled Distance Units (SDU). SDUs are defined not only in relation to the object&#39;s size itself, but also in relation to the distance from the viewer to the object itself.</p>
<p>For drawables attached to <a href="../Reference/JavaScript%20API/classes/GeoObject.html"><code>AR.GeoObject</code></a>, 1 SDU is defined as the screen-size of an object which is exactly 1 meter high and located 10 meters away from the viewer. If a drawable&#39;s width is defined as 5 SDU, it will exactly overlap an object which is 5 meters wide and is located in 10 meters distance.
For drawables attached to <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObjects</code></a>, SDUs are determined by the underlying trackable&#39;s size. The drawables anchor point will be set to the center of the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>AR.Trackable2DObjects</code></a>, and 1 SDU is defined to be the height of the image, as described in the figure below:</p>
<p><img src="images/sdu_Trackable2DDrawables.jpg" alt=""></p>
<p>A circle with radius set to 0.25 will then be rendered accordingly like shown in the image below:
<img src="images/sdu_circleInTrackable.jpg" alt=""></p>
<h3 id="distance-based-scaling-dbs-">Distance Based Scaling (DBS)</h3>
<p>Another important concept of an AR application is &quot;Distance Based Scaling&quot;. Think about the logo again, which represents the store location of a certain brand. If the viewer is about 10 meters away and looking at the store, the logo will perfectly overlap the building, given that we have set the drawable&#39;s width and height to the right SDUs. Now, let&#39;s put the view further away from the store location. Without the concept of DBS, the logo will quickly vanish from the screen, as it will be too small to see - especially when the SDUs are not set to a high value. A similar situation appears when we are moving towards the location - the logo will soon appear very big and obstruct the entire screen.</p>
<p>To avoid situations, where drawables are only clearly visible in a certain viewing distance or are otherwise too big or too small to recognize respectively, the Wikitude ARchitect introduces  a concept called Distance Based Scaling (DBS). It ensures that drawables do not exceed certain limits of their original appearance.</p>
<p>We define two values, <a href="../Reference/JavaScript%20API/classes/context.html#property_scene.minScalingDistance"><code>scene.minScalingDistance</code></a> and <a href="../Reference/JavaScript%20API/classes/context.html#property_scene.maxScalingDistance"><code>scene.maxScalingDistance</code></a>.</p>
<p><a href="../Reference/JavaScript%20API/classes/context.html#property_scene.minScalingDistance"><code>scene.minScalingDistance</code></a> is set to 10 meters and defines the viewing distance at which the drawables will not be scaled anymore. Regardless whether the viewing distance is 10 meters or even closer to the original location, the drawable will still have the same size on the screen. This avoids drawables obstructing the entire screen.</p>
<p><a href="../Reference/JavaScript%20API/classes/context.html#property_scene.maxScalingDistance"><code>scene.maxScalingDistance</code></a> is set to 20 kilometers and defines the viewing distance beyond which the drawables will not be scaled anymore. The drawable will still appear in the same size on the screen, regardless if the distance to the object is 20 kilometers, or even more. This avoids drawables getting too small to see on the screen.</p>
<p>The <a href="../Reference/JavaScript%20API/classes/context.html#property_scene.maxScalingDistance"><code>scene.maxScalingDistance</code></a> size of the drawable is set to 10% of its size at <a href="../Reference/JavaScript%20API/classes/context.html#property_scene.minScalingDistance"><code>scene.minScalingDistance</code></a> (the defined SDU-value), resulting in any drawable not appearing smaller than 10% of its size if the object was only 10 meters away.</p>
<p>Between <a href="../Reference/JavaScript%20API/classes/context.html#property_scene.minScalingDistance"><code>scene.minScalingDistance</code></a> and <a href="../Reference/JavaScript%20API/classes/context.html#property_scene.maxScalingDistance"><code>scene.maxScalingDistance</code></a>, the objects are scaled based on a scaling function of x^(0.2). The effect of this particular scaling function is that drawables representing near objects are downscaled fairly quickly as the user is moving away from the object. The further the user moves away from the object, the lesser the loss of size will be visible for the user, to allow a smooth user experience.</p>

<h1 id="migration">Migration</h1>
<h2 id="migrate-from-4-1-to-5-0">Migrate from 4.1 to 5.0</h2>
<ul>
<li>Projects now require Android 4.0+</li>
</ul>
<h2 id="migrate-from-4-0-to-4-1">Migrate from 4.0 to 4.1</h2>
<ul>
<li><p>ArchitectView</p>
<ul>
<li><code>ArchitectView.ArchitectConfig</code> has been replaced by the new class <code>StartupConfiguration</code></li>
<li><code>ArchitectView.ARMode</code> has been replaced by the new interface <code>StartupConfiguration.Features</code></li>
<li>the method <code>getSupportedARModeForDevice()</code> has been renamed to <code>getSupportedFeaturesForDevice()</code></li>
<li>the method <code>getVersionNumber()</code> has been renamed to <code>getSdkVersion()</code></li>
</ul>
</li>
<li><p>The Wikitude SDK 4.1 introduces a new file format for target collections (wtc). In order to unleash the full power of the new Wikitude SDK 4.1 read <a href="migration.html#migrate-from-40-to-41">this section</a> and re-generate your targets. The old format is deprecated and will be removed in future versions.  </p>
</li>
</ul>
<h2 id="migrate-from-3-3-to-4-0">Migrate from 3.3 to 4.0</h2>
<ul>
<li>Make sure to set the required permissions for your application when using the new <code>AR.context.hardware.flashlight</code> API.</li>
<li>Starting with Wikitude SDK 4.0 a valid license key is mandatory for starting the SDK. An empty license key will block the SDK. A free trial key can be generated on the <a href="http://www.wikitude.com/developer/licenses">license page</a> (free account required).</li>
<li>The Wikitude SDK 4.0 introduces a new file format for target collections (wtc). In order to unleash the full power of the new Wikitude SDK 4.0 read <a href="migration.html#migrate-from-40-to-41">this section</a> and re-generate your targets.</li>
<li><p>In Version 4.0 of our SDK, we changed the initialization procedure, and we open the camera immediately when the ArchitectView is initialized, to improve the overall performance. You should not call <code>Camera.open()</code> after <code>ArchitectView.onCreate()</code>, if you need any information about the camera, you can open (and then close) it before initializing the ArchitectView.</p>
<p>  Any other operation on the camera when the ArchitectView is active is actually &quot;undefined behaviour&quot; and was not supposed to work even in previous SDK versions.</p>
</li>
</ul>
<h2 id="migrate-from-3-2-to-3-3">Migrate from 3.2 to 3.3</h2>
<p>The SDK is compatible with Android 4.4, so we recommend to update ADT to the latest version and set the target SDK version to &#39;19&#39; in your Android Manifest XML file.</p>
<h2 id="migrate-from-3-1-to-3-2">Migrate from 3.1 to 3.2</h2>
<p><code>ArchitectUrlListener</code> and <code>SensorAccuracyChangeListener</code> are now inner interfaces of the <code>ArchitectView</code> class. Update your imports in your Android code accordingly to get rid of compile time errors (<code>ArchitectUrlListener</code> becomes <code>ArchitectView.ArchitectUrlListener</code>).</p>
<h2 id="migrate-from-3-0-to-3-1">Migrate from 3.0 to 3.1</h2>
<h3 id="image-recognition-and-tracking">Image Recognition and Tracking</h3>
<p>The image recognition engine of Wikitude SDK 3.1 has been updated resulting in shorter time interval to successfully recognize a target image. As a consequence the format of the digital footprint of target image has changed. The format is backward compatible. Developers still can use target collections (.wtc) generated with Wikitude SDK 3.0 (prior to 27th August 2013) together with the SDK 3.1 and vice versa.</p>
<p>However we recommend to generate your target collections again in the Target Manager Tool and update the files when you are using Wikitude SDK 3.1</p>
<h3 id="html-drawables">HTML Drawables</h3>
<p>Developers using HTML Drawables in projects prior to Wikitude SDK 3.1 and like to upgrade to 3.1 need to define the <code>viewportHeight</code> similar to the already defined <code>viewportWidth</code>. In addition HTML Drawables do not have to be created as static or dynamic anymore. All are created as dynamic ones.</p>
<h2 id="migrate-from-2-0-to-3-0">Migrate from 2.0 to 3.0</h2>
<p>Wikitude SDK version 3.0 introduces Wikitude&#39;s own image recognition and tracking solution and removes support for the Vuforia Plugin. </p>
<p>If you are not using image recognition features in your app you only need to update the jar file and are good to go.</p>
<p>In case you are making use of image recognition features and want to switch from 2.0 to 3.x version remove any Qualcomm/Vuforia related assets (QCAR.so, QCAR.lib) from your project.
Also the <code>READ_PHONE_STATE</code> permission is no longer required in your AndroidManifest.xml.</p>
<p>Find a step-by-step guide about how to convert your existing target collection from Vuforia to Wikitude <a href="targetmanagement.html#migrate_targets">here</a>.</p>
<h2 id="upgrading-targets-for-sdk-4-1">Upgrading targets for SDK 4.1</h2>
<p>The Wikitude SDK 4.1 introduces an updated format for the target collection. The new format improves the recognition phase considerably. The updated format is not backward compatible with Wikitude SDK 3.x, 4.0 and can not be used in projects using Wikitude SDK 3.x or Wikitude SDK 4.0. </p>
<p>However you can use wtc-3.x and wtc-4.0 formats with the Wikitude SDK 4.1, although we strongly recommend to updated to the newest (wtc-4.1) version.</p>
<div class="warning">
<strong>Support for wtc-3.x and wtc-4.0 is deprecated and will be not supported in Wikitude SDK 5.0 (later 2015)</strong>. 
</div>

<p>To use the new format you need to re-create your target collection in the <a href="http://www.wikitude.com/developer/tools/target-manager" target="_top">target manager</a> and download the <code>.wtc</code> file under the <code>Download 4.1</code> link. Put this <code>.wtc</code> file in your app and replace the previous one.</p>
<div class="warning">
    It is not possible to use a wtc 4.1 file together with Wikitude SDK 3.x or Wikitude SDK 4.0. Please download the respective wtc versions from the target manager and use them.
</div>

<table>
    <tr>
        <th></th>
        <th>Wikitude SDK 3.x</th>
        <th>Wikitude SDK 4.0</th>
        <th>Wikitude SDK 4.1</th>
    </tr>
    <tr>
        <td>wtc 3.x</td>
        <td class="supported">supported</td>
        <td class="supported">supported</td>
        <td class="supported">supported</td>
    </tr>
    <tr>
        <td>wtc 4.0</td>
        <td class="not-supported">not supported</td>
        <td class="supported">supported</td>
        <td class="supported">supported</td><br>    </tr>
     <tr>
        <td>wtc 4.1</td>
        <td class="not-supported">not supported</td>
        <td class="not-supported">not supported</td>
        <td class="supported">supported</td><br>    </tr>

</table>



<h2 id="migrating-targets-from-sdk-1-x">Migrating targets from SDK 1.x</h2>
<p>If you have been using a dataset from the Qualcomm Vuforia target management, please follow these steps to convert your ARchitect World to the new approach:</p>
<ol>
<li>Create a new project with the Wikitude target management tool and upload your targets (see instructions above)</li>
<li>Create a target collection and store it in the same location as the previously used <em>dataset</em></li>
<li>In your ARchitect World, update the  <a href="../Reference/JavaScript%20API/classes/ClientTracker.html"><code>AR.ClientTracker</code></a> initialization to point to the URL of your new target collection</li>
</ol>

<h1 id="wikitude-sdk-android-release-notes">Wikitude SDK Android Release Notes</h1>
<h2 id="wikitude-sdk-5">Wikitude SDK 5</h2>
<h3 id="wikitude-sdk-5-1-1">Wikitude SDK 5.1.1</h3>
<p>Release Date: 12.01.2016</p>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Missing textures on certain 3D models</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Wikitude Sample App now implements Android Runtime Permissions (applies to Android 6.0 - API level 23)</li>
</ul>
<h3 id="wikitude-sdk-5-1-0">Wikitude SDK 5.1.0</h3>
<p>Release Date: 01.12.2015</p>
<h4 id="new">New</h4>
<ul>
<li>Support for Android switched camera on Nexus 5X</li>
<li>Support multiple regional co-located cloud recognition services</li>
<li>3D model import: account for pivot node transformations</li>
</ul>
<h4 id="fixed">Fixed</h4>
<ul>
<li>3D model import: <ul>
<li>Animation grouping</li>
<li>Account for animation stack (numbering of animations if more than one animation tracks are on the FBX animation stack)</li>
<li>Accept the first texture of a multi-textured 3d model</li>
<li>Accept 3d models with more than one mesh skins per node</li>
</ul>
</li>
</ul>
<h3 id="wikitude-sdk-5-0-0">Wikitude SDK 5.0.0</h3>
<p>Release Date: 27.08.2015</p>
<h4 id="new">New</h4>
<ul>
<li>Extended Tracking</li>
<li>Plugins API</li>
<li>Full Android Studio setup and support</li>
<li>Unity Plugin</li>
<li>Native API </li>
</ul>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Potential problem with 3D special effects causing crashes</li>
<li>Potential problem when calling <code>trackable.drawables.addCamDrawable()</code> while snapping is active</li>
<li>Wrong log messages for connection not found</li>
<li>Potential problem when clicking parts of a 3D model</li>
<li>Potential problem when 3D models are re-loaded fast</li>
<li>Potential memory increase with certain 3D models</li>
<li>Problem when at the same time addCamDrawable is called in the onExitFieldOfVision event</li>
<li>Potential problem with texture rendering when clicking a button</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Newest version of 3D rendering engine</li>
</ul>
<h4 id="removed">Removed</h4>
<ul>
<li>Official support for Android version lower than Android 4.0</li>
</ul>
<h2 id="wikitude-sdk-4-1">Wikitude SDK 4.1</h2>
<h3 id="wikitude-sdk-4-1-1">Wikitude SDK 4.1.1</h3>
<p>Release Date: 27.04.2015</p>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Missing QT 5 .dll&#39;s for Windows 3D Encoder</li>
<li>AR.Model <code>onError</code> handler now has more details about what failed</li>
<li>Loading of <a href="../Reference/JavaScript%20API/classes/ClientTracker.html"><code>ClientTracker</code></a> works as expected when no <code>onLoaded</code> trigger is set</li>
<li>Documentation clarifications and fixes </li>
<li>Updated Terms of Service</li>
</ul>
<h3 id="wikitude-sdk-4-1-0">Wikitude SDK 4.1.0</h3>
<p>Release Date: 03.03.2015</p>
<h4 id="new">New</h4>
<ul>
<li>Access to the device front cam through a JavaScript API and the native SDK</li>
<li>Hardware access API for advanced camera features (zoom, focus)</li>
<li>Native support for 64-bit ARM devices</li>
<li>Information about distance to the image target</li>
<li>Click on 3D model now returns mesh part</li>
<li>Updated sample app</li>
<li><code>CloudTracker</code> for cloud recognition support</li>
<li>API changes<ul>
<li>moved all initialization parameters to new class <code>StartupConfiguration</code></li>
<li>renamed <code>ARMode</code> to <code>Features</code></li>
<li>uniform naming convention of API methods on all platforms  </li>
</ul>
</li>
</ul>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Potential problem when deleting large <code>.wtc</code> files</li>
<li><code>onSnappedToScreen</code> function is not called when using the <code>enabledOnExitFieldOfVision</code> property</li>
<li>3D Model with animation not clickable</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Performance of Image Recognition initial recognition phase</li>
<li>Tracking Performance optimized and streamlined</li>
</ul>
<h2 id="wikitude-sdk-4-0">Wikitude SDK 4.0</h2>
<h3 id="wikitude-sdk-4-0-3-drc">Wikitude SDK 4.0.3 DRC</h3>
<p>Release Date: 25.11.14</p>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Race condition on ArchitectView startup (leading to crash) when Javascript command are issued before the main HTML is loaded.</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Better handling of AR worlds containing more VideoDrawables.</li>
</ul>
<h3 id="wikitude-sdk-4-0-3">Wikitude SDK 4.0.3</h3>
<p>Release Date: 28.10.14</p>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Compatibility with Android 5.0</li>
</ul>
<h3 id="wikitude-sdk-4-0-2">Wikitude SDK 4.0.2</h3>
<p>Release Date: 09.10.14</p>
<h4 id="new">New</h4>
<ul>
<li>Android L compliance, according to the new guidelines</li>
<li>AR Mode configurable on startup (default is IR+Geo)</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Image target recognition</li>
<li>Optimized SDK for Android 2.3+ by removing fallbacks for older Android versions</li>
</ul>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Fixes an issue with flickering augmentations for certain image targets</li>
<li>Fixes an issue where the &#39;onSnappedToScreen&#39; function was not called when using the &#39;enabledOnExitFieldOfVision&#39; property</li>
<li>It is safe to call normal lifecycle events of the ARchitectView even if initialization fails</li>
<li>ARchitect WebView lifecycle doesn&#39;t interfere with other WebViews in the same application</li>
</ul>
<h3 id="wikitude-sdk-4-0-1">Wikitude SDK 4.0.1</h3>
<p>Release Date: 07.08.14</p>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Fixes Videodrawable crash related to code obfuscation when creating a Play Store application</li>
<li>Fixes Videodrawable loop behaviour on Samsung devices.</li>
</ul>
<h3 id="wikitude-sdk-4-0-0">Wikitude SDK 4.0.0</h3>
<p>Release Date: 29.07.14</p>
<h4 id="new">New</h4>
<ul>
<li>Support for x86 architecture</li>
<li>&quot;Snap-to-screen&quot; feature (see samples <a href="3dmodels.html#snapToScreen">3D Model</a> and <a href="video.html#snappedvideo">Video</a> for implementation)</li>
<li>Wildcard support for the <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html#property_targetName"><code>targetName</code></a> property of <a href="../Reference/JavaScript%20API/classes/Trackable2DObject.html"><code>Trackable2DObject</code></a></li>
<li>New tracking engine with increased performance </li>
<li>Control flash light from augmented reality scene (<a href="../Reference/JavaScript%20API/classes/context.html#property_hardware.flashlight"><code>AR.context.hardware.flashlight</code></a>)</li>
<li>SDK version number is now accessible from JS (<a href="../Reference/JavaScript%20API/classes/context.html#property_versionNumber"><code>AR.context.versionNumber</code></a>)</li>
<li>Updates OpenSSL version to 1.0.1h</li>
<li>Required license key</li>
</ul>
<h4 id="fixed">Fixed</h4>
<ul>
<li>A potential issue that caused rendering artifacts when objects were created outside of the current culling distance</li>
<li>Fixes a problem with wrong camera orientation</li>
<li>Fixes various problems with VideoDrawables</li>
<li>Fixes a potential issue with 3D models that were not deleted correctly from a temporary directory</li>
<li>Fixes a potential issue with 3D models that were not destroyed correctly when using the JS <code>destroy()</code> API</li>
<li>Transparent videos on PowerVR SGX 540 devices</li>
<li>Can load the same 3D model more than once</li>
<li>VideoDrawables crash on pause / resume</li>
<li>Load and show more than one video in a single AR world</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Samples to reflect Snap-to-screen feature and wildcard support</li>
<li>Comments in sample apps source code</li>
</ul>
<h2 id="wikitude-sdk-3-3">Wikitude SDK 3.3</h2>
<h3 id="wikitude-sdk-3-3-2">Wikitude SDK 3.3.2</h3>
<p>Release Date: 29.07.14</p>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Fixes various problems with VideoDrawables</li>
<li>Fixes a potential issue with 3D models that were not deleted correctly from a temporary directory</li>
<li>Updates OpenSSL version to 1.0.1h</li>
<li>Transparent videos on PowerVR SGX 540 devices</li>
<li>Can load the same 3D model more than once</li>
<li>VideoDrawables crash on pause / resume</li>
<li>Load and show more than one video in a single AR world</li>
</ul>
<h3 id="wikitude-sdk-3-3-1">Wikitude SDK 3.3.1</h3>
<p>Release Date: 24.04.2014</p>
<h4 id="new">New</h4>
<ul>
<li>Listener for PageLoaded Event</li>
</ul>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Possible memory allocation issues during application close</li>
<li>Possible error where screenshot was not captured</li>
<li>Crash when exiting and reentering the same architect world</li>
<li>Some PNG images couldn&#39;t be loaded</li>
</ul>
<h3 id="wikitude-sdk-3-3-0">Wikitude SDK 3.3.0</h3>
<p>Release Date: 01.04.2014</p>
<h4 id="new">New</h4>
<ul>
<li>Multiple AR views supported</li>
<li>URL scheme support for <code>tel:</code>, <code>sms:</code> and <code>mailto:</code></li>
<li>Scaling mode: Global Scene (See <a href="../Reference/JavaScript%20API/classes/context.html">JavaScript API Reference</a>for more details)</li>
<li>Method getSupportedARModeForDevice to retrieve suitable AR mode for device</li>
</ul>
<h4 id="fixed">Fixed</h4>
<ul>
<li>JavaScript error reported at start-up (Uncaught ReferenceError)</li>
<li>Possible mix-up of 3D textures with the same name in different 3D models</li>
<li>Possible exception when using Video Drawable (ConcurrentModificationException) fixed</li>
<li>Possible crash when sending app to background and back when playing video</li>
<li>Loading of worlds from SD card on Android 3.0 (and earlier) and sound loading from SD card</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Camera View on low-end devices</li>
<li>Injection of JavaScript API on Android 3.0+</li>
<li>Compatibility with Android 4.4 and SDK 19</li>
</ul>
<h2 id="wikitude-sdk-3-2">Wikitude SDK 3.2</h2>
<h3 id="wikitude-sdk-3-2-1">Wikitude SDK 3.2.1</h3>
<p>Release Date: 04.12.2013</p>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Compilation error preventing gif files to be shown in AR scene</li>
<li>Animation loops of 3D models</li>
<li>onError trigger not called for images in not supported format</li>
<li>Rare cases where Android UI becomes unresponsive when opening an activity on top of Wikitude SDK</li>
</ul>
<h3 id="wikitude-sdk-3-2-0">Wikitude SDK 3.2.0</h3>
<p>Release Date: 10.10.2013</p>
<h4 id="new">New</h4>
<ul>
<li>VideoDrawables to display videos on top of image targets or as part of <code>GeoObjects</code></li>
<li>Taking screenshot of AR scene</li>
<li>Examples for VideoDrawables</li>
</ul>
<h4 id="fixed">Fixed</h4>
<ul>
<li><code>AR.context.startVideoPlayer</code> was unable to play videos from asset folder</li>
<li>ADE.js interfered with architect.js under certain circumstances when loaded from bundle/assets</li>
<li>Rare case of crashing in <code>onDestroy</code></li>
<li>Under certain circumstances the sensors where not paused </li>
<li>Camera uses auto focus for better recognition performance</li>
<li>Fixed loading worlds from any source</li>
<li>Changing viewport of HTML drawable after creation results in crash</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Resource loading and caching of images, 3D models and tracker files</li>
<li>Images can be loaded from any source</li>
<li>Loading time of image recognition tracker</li>
<li>Radar position and size is now defined as a DOM element (e.g. div-tag styled in CSS). That way you can define scale and position in HTML instead of defining offsets in SDU unit.</li>
<li>Browse POI samples</li>
</ul>
<h2 id="wikitude-sdk-3-1">Wikitude SDK 3.1</h2>
<h3 id="wikitude-sdk-3-1-0">Wikitude SDK 3.1.0</h3>
<p>Release Date: 27.08.2013</p>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Problem with included ade.js on device interfered with ARchitect API</li>
<li>AnimatedImageDrawable&#39;s frame rate was ignored after resume.</li>
<li>Executing onDocumentLocationChanged trigger for HTML Drawable in ADE was broken.</li>
<li>Under certain circumstances SDK didn&#39;t pause when switched to background.</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>HTML Drawables work correctly with dynamic content</li>
<li>Image detection two times faster</li>
<li>Better support for target images with low contrast</li>
<li>More reliable tracking, especially for difficult target images</li>
<li>Optimized texture memory usage for non square images</li>
</ul>
<h2 id="wikitude-sdk-3-0">Wikitude SDK 3.0</h2>
<h3 id="wikitude-sdk-3-0-1">Wikitude SDK 3.0.1</h3>
<p>Release Date: 25.07.2013</p>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Orientation issue for Android tablets</li>
</ul>
<h3 id="wikitude-sdk-3-0-0">Wikitude SDK 3.0.0</h3>
<p>Release Date: 18.06.2013</p>
<h4 id="new">New</h4>
<ul>
<li>Integrated image recognition and tracking engine</li>
<li>Examples application</li>
<li>Support for 3D model animations</li>
<li>Support for transparent materials, textures and colors on 3D models</li>
<li>API method for setting distance based scaling parameters. See reference on AR.context.scene</li>
</ul>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Under certain circumstances the light of a 3D model was ignored</li>
<li>Issue when locking screen and radar is visible</li>
<li>Possible crash when using wrong license key</li>
<li>Possible crash when returning to an ArchitectView that uses HTMLDrawables</li>
<li>Aspect ratio in camera for devices with image recognition capability</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Image recognition supports up to 1000 targets</li>
<li>Rewritten, extended and improved SDK documentation.</li>
<li>Significant increase of performance at start up and general performance increase</li>
<li>Minor fixes</li>
</ul>
<h4 id="removed">Removed</h4>
<ul>
<li>Support for Vuforia SDK</li>
</ul>
<h2 id="wikitude-sdk-2-0">Wikitude SDK 2.0</h2>
<h3 id="wikitude-sdk-2-0-0">Wikitude SDK 2.0.0</h3>
<p>Release Date: 26.02.2013</p>
<h4 id="new">New</h4>
<ul>
<li>Support for 3D models via new ARchitect class Model </li>
</ul>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Missing SD card prevented image recognition from running successfully.</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Minor fixes and performance improvements</li>
</ul>
<h2 id="wikitude-sdk-1-2">Wikitude SDK 1.2</h2>
<h3 id="wikitude-sdk-1-2-0">Wikitude SDK 1.2.0</h3>
<p>Release Date: 18.12.2012</p>
<h4 id="new">New</h4>
<ul>
<li>Improved bridge performance (SteelBridge and Weasel)</li>
<li>onFinish trigger for AnimatedImageDrawables</li>
<li>ImageResource onLoad() reports width and height of loaded image</li>
<li>PropertyAnimation can be paused and resumed</li>
<li>Customize clicking behavior (click, touch down, touch up)</li>
<li>Set culling distance from JavaScript</li>
<li>Support for Vuforia SDK v2.0</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Architect Desktop Engine (ADE) now overlays world</li>
</ul>
<h2 id="wikitude-sdk-1-1">Wikitude SDK 1.1</h2>
<h3 id="wikitude-sdk-1-1-1">Wikitude SDK 1.1.1</h3>
<p>Release Date: 26.09.2012</p>
<h4 id="fixed">Fixed</h4>
<ul>
<li>Possible crash when using openInBrowser or startVideoPlayer while IR is active</li>
<li>Possible crash when calling start / stop while IR is active</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>Minor performance increase for rendering HTML drawables.</li>
<li>Handling of images with semi transparency</li>
</ul>
<h3 id="wikitude-sdk-1-1-0">Wikitude SDK 1.1.0</h3>
<p>Release Date: 16.08.2012</p>
<h4 id="new">New</h4>
<ul>
<li>HTML Drawables </li>
<li>Relative locations </li>
<li>Customizable AR radar</li>
<li>Sprite Animations</li>
<li>3D Transformation</li>
<li>Animation Groups</li>
<li>Extension for Qualcomm Vuforia SDK for Image Recognition</li>
<li>Possibility to turn off camera and sensors</li>
<li>Possibility to add a single drawable to multiple GeoObjects</li>
</ul>
<h4 id="improved">Improved</h4>
<ul>
<li>New tutorials and snippets</li>
<li>Library Reference examples and texts</li>
<li>New simple IR example</li>
<li>Streamlined trigger properties</li>
<li>Rendering performance in general</li>
<li>Performance of AR.logger output on device</li>
</ul>
<h2 id="wikitude-sdk-1-0">Wikitude SDK 1.0</h2>
<h3 id="wikitude-sdk-1-0-5">Wikitude SDK 1.0.5</h3>
<h4 id="new">New</h4>
<ul>
<li>Added setCullingDistance to ArchitectView (SDK)</li>
<li>Added possibility for better error handling when loading an ARchitect World (SDK)</li>
<li>Improved SimpleARBrowser example</li>
</ul>
<h4 id="note">Note</h4>
<ul>
<li>Including a viewport meta-tag in your ARchitect World is recommended if you target different screen resolutions (see ARchitectTools/Hello World/Hello World.html for more details)</li>
</ul>
<h3 id="wikitude-sdk-1-0-4">Wikitude SDK 1.0.4</h3>
<ul>
<li>Licensable SDK</li>
</ul>
<h3 id="wikitude-sdk-1-0-3">Wikitude SDK 1.0.3</h3>
<ul>
<li>Initial Public SDK Release</li>
</ul>


            <footer id="footer">
                &copy; 2012 -2015 <a href="http://www.wikitude.com">Wikitude GmbH</a> · <a href="http://www.wikitude.com/imprint">Imprint</a>
            </footer>  
        </div>    
    </div>

    <!-- TO DO: Reactivate when problems with nav are fixed
    <script>
    $(function(){
            $("#toc ul").treemenu({delay:300}).openActive();
        });
    </script>
    -->

</body>
    <script>
    var lightbox = new Lightbox();
    lightbox.load();
    </script>

</html>
